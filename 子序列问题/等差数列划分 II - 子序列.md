# [等差数列划分 II - 子序列](https://leetcode.cn/problems/arithmetic-slices-ii-subsequence)

![image-20250408194840399](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408194840533.png)

## 题目解析

给你一个整数数组 `nums` ，返回 `nums` 中所有 **等差子序列** 的数目。

如果一个序列中 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该序列为等差序列。

- 例如，`[1, 3, 5, 7, 9]`、`[7, 7, 7, 7]` 和 `[3, -1, -5, -9]` 都是等差序列。
- 再例如，`[1, 1, 2, 5, 7]` 不是等差序列。

**示例一**

>```
>输入：nums = [2,4,6,8,10]
>输出：7
>解释：所有的等差子序列为：
>[2,4,6]
>[4,6,8]
>[6,8,10]
>[2,4,6,8]
>[4,6,8,10]
>[2,4,6,8,10]
>[2,6,10]
>```

我们固定`2,4`就得到了`[2,4,6]`
我们固定`2,6`就得到了`[2,6,10]`
`2,8`后面没数了
我们固定`4,6`就得到了`[4,6,8]`
我们固定`4,8`后面没数了
我们固定`6,8`就得到了`[6,8,10]`
我们固定`[2,4,6]`, 就得到了`[2,4,6,8]`
我们固定`[4,6,8]`,就得到了`[4,6,8,10]`
最后还有它自己, `[2,4,6,8,10]`

## 算法原理

- **状态表示**
  我们可以先蒙一下, 之前我们总是说依据经验和题意, 实际上就是先蒙一个, 所以我们先定义`dp[i]`表示以`i`位置的元素(记为`b`)为结尾的所有子序列中, 等差子序列的个数
- **状态转移**
  我们先在`b`前面找个位置`k`, 记`k`位置的值为`a`, 然后尝试看看能不能和以`a`位置为结尾的等差子序列并在一起, 从而继承`dp[a]`的状态, 很明显, 这做不到, 因为仅靠`b`这个数, 它无法确定一个等差数列, 所以`b`拼到`a`后面, 所形成的新序列, 完全可能不是等差子序列, 所以很明显, 我们蒙错了
- **状态表示**
  既然以一个数为结尾确定不了一个等差子序列, 那么, 以两个数为结尾呢? 很明显, 是可以的, 因为如果以两个数为结尾, 因为末尾两个数是固定的, 所以就有确定的公差, 所以就能继续往前推导, 进而确定一个等差子序列, 为方便起见, 我们记`nums[i] = b, nums[j] = c`, 那么, 便可以定义`dp[i][j]`为以`[b,c]`为结尾的所有子序列中, 等差序列的个数
- **状态转移**
  当我们知道末尾的两个数, 也就是`[b,c]`后, 就能很容易推出更前面的一个数, 我们记为`a`, 并规定`a`的下标为`k`, 对于`a`来说, 它可能有三种情况, 一是在`j`后面或者根本没有, 因为子序列不能改变相对顺序, 所以对于这种情况, 它就构成不了等差子序列, 所以此时的`dp[i][j] = 0`, 第二种情况是, `a`夹在`i, j`之间, 对于这种情况, 它仍然是不符合相对顺序的, 所以很明显, 也构成不了等差子序列, 此时`dp[i][j] = 0`, 第三种情况是, `a`在`i`前面, 此时就可以构成一个`[a,b,c]`的等差子序列, 这就得到了一个等差子序列, 另外, 以`[a,b]`为结尾的等差子序列的公差仍旧是`c-b`, 这意味着`c`可以接上去, 这样就形成另外一些等差子序列, 所以对于这种情况, `dp[i][j] = 1 + dp[k][i]`, 另外需要注意的是, 题目要求的是总个数, 但可能存在多个符合子序列位置要求的`a`, 我么对于这些`a`都要考虑, 我们记这些前面的`a`的下标为`k_1, k_2....  k_x`, 因为要总个数, 所以它们都要加,
  ![image-20250408202120627](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408202120666.png)
  现在我们要处理一个小问题, 那就是如何找到符合位置顺序要求`a`的下标`k`, 为此我们有两种方案, 它们用的都是`unordered_map<int, vector<int>>`, 第一种方案是, 在最开始就整体统计一下, 填`dp`的时候注意一下下标, 小标不满足要求的就不要再累加了, 另外一种方案即使边填`dp`, 边填`hash`, 具体做法是`i`单向移动, 或者说, 它在外层循环, `j`在内层循环里来回跑, 每次`i`更新, 都把前面的`nums`值和下标存进去, 对于这种情况, 下标肯定是符合要求的, 所以闭着眼加就行, 我们这里选第二种
- **初始化**
  最差情况是`0`个个数, 这也是状态转移中许多情况的`dp`值, 这样初始化的话, 对于这些情况就可以直接略过
- **填表顺序**
  `dp[i][j]`的初始化可能用到`dp[k][i]`, 因为`k < i < j`, 所以`dp[k][i]`在`dp[i][j]`上面, 所以初始化顺序应该是从左往右, 从上往下
- **返回值**
  尽管有些格子没有实际意义, 比如`dp[1][0]`, 但由于它们的值都是最开始的`0`, 因此直接累加也并无影响, 或者你也可以在填表时累加, 这样只会累加用实际意义的格子.

## 代码编写

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n = nums.size(), result = 0;
        vector<vector<int>> dp(n, vector<int>(n));
        unordered_map<long long, vector<int>> hash;
        for(int i = 1; i < n-1; ++i)
        {
            long long b = nums[i];
            hash[nums[i-1]].emplace_back(i-1);
            for(int j = i + 1; j < n; ++j)
            {
                long long c = nums[j];
                long long a = 2 * b - c;
                if(hash.count(a) == 1)
                {
                    for(auto e : hash[a])
                    {
                        dp[i][j] += dp[e][i] + 1;
                    }
                }
                result += dp[i][j];
            }
        }
        return result;
    }
};
```

这里用`long long`是因为他有一个很特别的例子, `[0,2000000000,-294967296]`, 以`2000000000`为`b`, 以`-294967296`为`c`求出的`a`是`4294967296`, 对于`int`来说, 它恰好溢出成为`0`.

# 完