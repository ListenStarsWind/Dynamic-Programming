# [等差数列划分 II - 子序列](https://leetcode.cn/problems/arithmetic-slices-ii-subsequence)

![image-20250408194840399](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408194840533.png)

## 题目解析

给你一个整数数组 `nums` ，返回 `nums` 中所有 **等差子序列** 的数目。

如果一个序列中 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该序列为等差序列。

- 例如，`[1, 3, 5, 7, 9]`、`[7, 7, 7, 7]` 和 `[3, -1, -5, -9]` 都是等差序列。
- 再例如，`[1, 1, 2, 5, 7]` 不是等差序列。

**示例一**

>```
>输入：nums = [2,4,6,8,10]
>输出：7
>解释：所有的等差子序列为：
>[2,4,6]
>[4,6,8]
>[6,8,10]
>[2,4,6,8]
>[4,6,8,10]
>[2,4,6,8,10]
>[2,6,10]
>```

我们固定`2,4`就得到了`[2,4,6]`
我们固定`2,6`就得到了`[2,6,10]`
`2,8`后面没数了
我们固定`4,6`就得到了`[4,6,8]`
我们固定`4,8`后面没数了
我们固定`6,8`就得到了`[6,8,10]`
我们固定`[2,4,6]`, 就得到了`[2,4,6,8]`
我们固定`[4,6,8]`,就得到了`[4,6,8,10]`
最后还有它自己, `[2,4,6,8,10]`

## 算法原理

- **状态表示**
  我们可以先蒙一下, 之前我们总是说依据经验和题意, 实际上就是先蒙一个, 所以我们先定义`dp[i]`表示以`i`位置的元素(记为`b`)为结尾的所有子序列中, 等差子序列的个数
- **状态转移**
  我们先在`b`前面找个位置`k`, 记`k`位置的值为`a`, 然后尝试看看能不能和以`a`位置为结尾的等差子序列并在一起, 从而继承`dp[a]`的状态, 很明显, 这做不到, 因为仅靠`b`这个数, 它无法确定一个等差数列, 所以`b`拼到`a`后面, 所形成的新序列, 完全可能不是等差子序列, 所以很明显, 我们蒙错了
- **状态表示**
  既然以一个数为结尾确定不了一个等差子序列, 那么, 以两个数为结尾呢? 很明显, 是可以的, 因为如果以两个数为结尾, 因为末尾两个数是固定的, 所以就有确定的公差, 所以就能继续往前推导, 进而确定一个等差子序列, 为方便起见, 我们记`nums[i] = b, nums[j] = c`, 那么, 便可以定义`dp[i][j]`为以`[b,c]`为结尾的所有子序列中, 等差序列的个数
- **状态转移**
  当我们知道末尾的两个数, 也就是`[b,c]`后, 就能很容易推出更前面的一个数, 我们记为`a`, 并规定`a`的下标为`k`, 对于`a`来说, 它可能有三种情况, 一是在`j`后面或者根本没有, 因为子序列不能改变相对顺序, 所以对于这种情况, 它就构成不了等差子序列, 所以此时的`dp[i][j] = 0`, 第二种情况是, `a`夹在`i, j`之间, 对于这种情况, 它仍然是不符合相对顺序的, 所以很明显, 也构成不了等差子序列, 此时`dp[i][j] = 0`, 第三种情况是, `a`在`i`前面, 此时就可以构成一个`[a,b,c]`的等差子序列, 这就得到了一个等差子序列, 另外, 以`[a,b]`为结尾的等差子序列的公差仍旧是`c-b`, 这意味着`c`可以接上去, 这样就形成另外一些等差子序列, 所以对于这种情况, `dp[i][j] = 1 + dp[k][i]`, 另外需要注意的是, 题目要求的是总个数, 但可能存在多个符合子序列位置要求的`a`, 我么对于这些`a`都要考虑, 我们记这些前面的`a`的下标为`k_1, k_2....  k_x`, 因为要总个数, 所以它们都要加,
  ![image-20250408202120627](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408202120666.png)
  现在我们要处理一个小问题, 那就是如何找到符合位置顺序要求`a`的下标`k`, 为此我们有两种方案, 它们用的都是`unordered_map<int, vector<int>>`, 第一种方案是, 在最开始就整体统计一下, 填`dp`的时候注意一下下标, 小标不满足要求的就不要再累加了, 另外一种方案即使边填`dp`, 边填`hash`, 具体做法是`i`单向移动, 或者说, 它在外层循环, `j`在内层循环里来回跑, 每次`i`更新, 都把前面的`nums`值和下标存进去, 对于这种情况, 下标肯定是符合要求的, 所以闭着眼加就行, 我们这里选第二种
- **初始化**
  最差情况是`0`个个数, 这也是状态转移中许多情况的`dp`值, 这样初始化的话, 对于这些情况就可以直接略过
- **填表顺序**
  `dp[i][j]`的初始化可能用到`dp[k][i]`, 因为`k < i < j`, 所以`dp[k][i]`在`dp[i][j]`上面, 所以初始化顺序应该是从左往右, 从上往下
- **返回值**
  尽管有些格子没有实际意义, 比如`dp[1][0]`, 但由于它们的值都是最开始的`0`, 因此直接累加也并无影响, 或者你也可以在填表时累加, 这样只会累加用实际意义的格子.

## 代码编写

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n = nums.size(), result = 0;
        vector<vector<int>> dp(n, vector<int>(n));
        unordered_map<long long, vector<int>> hash;
        for(int i = 1; i < n-1; ++i)
        {
            long long b = nums[i];
            hash[nums[i-1]].emplace_back(i-1);
            for(int j = i + 1; j < n; ++j)
            {
                long long c = nums[j];
                long long a = 2 * b - c;
                if(hash.count(a) == 1)
                {
                    for(auto e : hash[a])
                    {
                        dp[i][j] += dp[e][i] + 1;
                    }
                }
                result += dp[i][j];
            }
        }
        return result;
    }
};

/*
    第二刷:
    定义dp[i][j]表示以[i][j]这两个元素为结尾的, 满足等差序列要求的子序列个数. i < j
    首先由nums[j] - nums[i]可以得到该等差序列的公差, 之后, 再去i的前面寻找目标k, 使得k
    加上公差能变为nums[i], 很明显, 进行线性搜索所耗费的时间过大, 我们可以使用哈希表来
    存储前面经历过的数值.

    如果找不到, 那么考虑到等差数列它至少有三个元素的特性, 我们只能将[i][j]位置定义为零
    如果找得到, 相等于是在之前的等差数列上, 等等, 之前可能没有等差数列, 这种情况就是找到
    了, 但里面的数值表现为零, 此时前面没有等差数列, 所以此时i,j位置只能变成一, 那如果不
    为零, 不为零意味着前面至少有三个元素, 那么这三个元素可以把i, 前面的想法是我多虑了, 根据
    状态表示, 子序列必须一i, j位置为结尾, 也就是说, 必须要有i,j位置, 我刚才再考虑要不要把
    只有i或者j的这些情况加上, 现在看来不需要, 此时, 满足要求的子序列就是以[k][i]为结尾的子序列
    再加上以[i][j]这两个元素, 所以就是它们本身的个数是, dp[k][i], 此外, 还有k, i, j这个, 所
    以要加上一.   现在要考虑一个问题, 对于多nums[k]同时存在的问题, 很显然, 这意味着等差数列在
    数值上将会相互重合, 但考虑到, 它们不是同一个序列, 我们决定要将其进行计数, 那么, 这样以来
    就需要分别计数, 每个k计数加一

    现在来看一下边界情况, 或者说是初始化条件,  似乎没什么好初始化的.

    在实际过程中, 为了避免重复建立哈希表, 对于 i , j 来说, 我们应该先固定i, 然后再固定j, 因为我们
    是在i前面找的, 这样的话, 就可以避免重复哈希的过程

    填表顺序, 考虑到i, j 依赖于   k, i, 考虑到行列的数目都减小了, 所以必然是当前位置依赖于左上角的
    位置, 那么第一行会不会有越界风险呢? 

    首先对于i为零的情况, 考虑到前面必然没有元素, 所以必然是零, 因此我们应该从i = 1的位置为开始
    所以应该先把[0]位置的值扔到哈希表里面, 然后该干什么就干什么

    为了方便起见, 原本打算直接在哈希表里面存pair int的对, 但或许我们可以预先造一个1000 * 1000的
    静态数组, 哈希是int, int模式, int1是目标值, int2是下标, 然后再查静态数组.

    返回值是怎样的? 是把每一种的i, j搭配的值都试一下吗? 看起来没有问题.

    注意类型范围问题, 有一个示例专门利用了类型范围做文章, 目的性诱发bug
    [0,2000000000,-294967296], 如果哈希用int会出错
*/

class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int dp[1000][1000] = {0};
        unordered_map<int64_t, vector<int>> hash;
        hash[nums[0]].push_back(0);

        int ans = 0;
        int n = nums.size();
        for(int i = 1; i < n; ++i)
        {
            for(int j = i + 1; j < n; ++j)
            {
                int64_t diff = (int64_t)nums[j] - (int64_t)nums[i];
                int64_t key = (int64_t)nums[i] - (int64_t)diff;
                if(hash.count(key) == 1)
                {
                    int count= 0;
                    for(auto k : hash[key])
                    {
                        count += dp[k][i] + 1;
                    }
                    ans += count;
                    dp[i][j] = count;
                }
            }
            hash[nums[i]].push_back(i);
        }
        return ans;
    }
};
```

这里用`long long`是因为他有一个很特别的例子, `[0,2000000000,-294967296]`, 以`2000000000`为`b`, 以`-294967296`为`c`求出的`a`是`4294967296`, 对于`int`来说, 它恰好溢出成为`0`.

# 完