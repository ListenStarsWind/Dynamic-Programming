# [摆动序列](https://leetcode.cn/problems/wiggle-subsequence)

![image-20250407103640105](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250407103640235.png)

## 题目解析

如果一个数字序列的走势呈现锯齿状, 则该序列就是摆动序列, 比如对于`[1, 7, 4, 9, 2, 6]`来说, 其走势就是这样的:
![image-20250407103824764](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250407103824837.png)

另外我们规定, 如果一个序列中只有一个元素, 那么也是摆序列,如`[7]`, 如果一个序列中只有两个元素, 并且它们并不相等, 那么也可以被视为摆动序列

**示例一**

>```
>输入：nums = [1,17,5,10,13,15,10,5,16,8]
>输出：7
>解释：这个序列包含几个长度为 7 摆动序列。
>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
>```

![image-20250407104537049](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250407104537112.png)

## 算法原理

- **状态表示**
  想要找到摆动子序列, 首先要找到子序列, 所以我们可以定义`dp[i]`为以`i`位置为结尾的子序列中最长摆动序列的长度, 但我们还不能定义得这么简单, 因为摆动序列的末尾有上升和下降这两种可能, 所以我们定义`f[i]`为以`i`位置为结尾的所有子序列中, 末尾呈现"上升"趋势的最长摆动序列长度, `g[i]`为以`i`位置为结尾的所有子序列中, 末尾呈现"下降"趋势的最长摆动序列长度
- **状态转移**
  对于以`i`为结尾的子序列, 可以大致分为两种, 一是`i`位置本身自成一个子序列, 二是, `i`连着它前面的元素(下标记为`j`)拼成一个子序列, 对于`f[i]`来说, 第一种情况的长度就是`1`, 而第二种情况, 由于`f[i]`表示"上升", 所以当`nums[j] < nums[i]`的时候, 才能考虑, 此时的最长序列不就是以`j`为结尾的末尾呈现"下降"趋势的最长摆动序列再加上`i`自身吗? 所以就是`g[j] + 1`, 对于`g[i]`来说, 也是如此.
  ![image-20250407110047942](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250407110048028.png)
- **初始化**
  我们可以为`f`和`g`的每个格子都定一个保底值, 它最小不就是一吗? 所以可以定为一, 这样也可以不考虑长度为一的情况了
- **填表顺序**
  从左往右
- **返回值**
  返回两个表中最大的那一个值

## 代码编写

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size(), result = 1;
        vector<int> f(n,1), g(n,1);
        for(int i = 1; i < n; ++i)
        {
            for(int j = i - 1; j >= 0; --j)
            {
                if(nums[j] < nums[i]) f[i] = max(f[i], g[j] + 1);
                if(nums[j] > nums[i]) g[i] = max(g[i], f[j] + 1);
            }
            result = max(result, max(f[i], g[i]));
        }
        return result;
    }
};
```

# 完