# [最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/)

![image-20250408172032248](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408172032322.png)

## 题目解析

给你一个整数数组 `nums`，返回 `nums` 中最长等差子序列的**长度**。

**示例一**

>```
>输入：nums = [3,6,9,12]
>输出：4
>解释： 
>整个数组是公差为 3 的等差数列。
>```

**示例二**

>```
>输入：nums = [9,4,7,2,10]
>输出：3
>解释：
>最长的等差子序列是 [4,7,10]。
>```

`9`和`4`, 公差为`-5`, 后面没有`-1`, `9`和`7`, 公差为`-2`, 后面没有`5`, `9`和`2`, 公差为`-7`, 后面没有`-5`, `9`和`10`, 后面没有元素, `4`和`7`, 公差为`3`, 有`10`, 最长的等差子序列是`[4,7,10]`

**示例三**

>```
>输入：nums = [20,1,15,3,10,5,8]
>输出：4
>解释：
>最长的等差子序列是 [20,15,10,5]。
>```

`20`和`1`, 后面没有`-18`, `20`和`15`, 下一个是`10`, 接下来是`5`, 最长为4

## 算法原理

- **状态表示**
  我们定义`dp[i]`表示以`i`位置为结尾的所有子序列中, 构成等差数列的最长子序列长度.
- **状态转移**
  首先, 我们先锁定`i`这个位置, 在前面寻找一个`j`位置, 看它们能不能构成一个等差子序列, 如果能, 那就是`dp[i] = dp[j] + 1`, 然后我们发现, 任意两个数都可以构成一个等差子序列, 但对于以`j`位置为结尾的等差子序列来说, 如果后面再接上`i`位置的元素, 可能就不是等差子序列了, 所以我们的状态表示有问题
- **状态表示**
  既然锁定一个数不行, 那锁定两个数呢? 当锁定两个数后, 它们的公差就可以计算出来, 由此就可以推出前面和后面的元素, 从而确定一个等差子序列, 所以我们定义`dp[i][j]`表示以`i`, `j`位置为结尾的所有子序列中, 构成等差数列的最长子序列长度.   为了方便起见, 我们记`nums[i] = b, nums[j] = c`, 所以`dp[i][j]`表示以`[b,c]`为结尾的所有子序列中, 构成等差数列的最长子序列长度
- **状态转移**
  根据子序列的末尾`[b,c]`, 我们可以很容易得到上一个元素`a`的值,从而构成`[a,b,c]`, 对此有`b-a = c-b`, 即`a = 2b-c`, 当我们求出`a`后, 存在三种情况, 第一种是, `a`根本不存在, 此时`[b,c]`仍可以构成一个等差子序列, 所以此时对应的值为`2`, 另一种可能是, 尽管`a`存在, 但它的位置并不符合子序列的标准, 它位于`i`, `j`两个位置之间, 但我们要找的是以`[b,c]`为结尾的最长子序列, 所以对于这种情况, 我们的`dp[i][j]`仍等于`2`, 第三种情况, 就是`a`存在, 并且, `a`在`b`前面,我们记`a`的下标是`k`,  此时就可以构成`[a,b,c]`等差子序列, 并且, `[a,b]`前面可能还继续还有相同等差的子序列, 所以此时`dp[i][j] = dp[k][i] + 1`不过这种情况还可以继续划分, 那就是它不止拥有满足位置先后顺序的`a`, 而且这个`a`还有多个, 由于我们要的最长的, 所以我们只需要选取其中最长的那个`dp[k][i]`就行了, 那到底哪个`a`对应的`dp[k][i]`最大呢? 其实很简单, 那就是最后面的, 最靠近`b`的`a`的`dp[k][i]`, 因为可以满足前面`a`的前缀子序列, 必然也可以满足后面的`a`, 但满足后面`a`的前缀子序列, 不一定能满足前面的`a`, 因为这个前缀子序列可能在前面`a`的后面, 所以最后面`a`的`dp[k][i]`一定是最大的
  ![image-20250408180141029](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408180141089.png)
  现在我们面临一个小问题, 那就是如何快速找到`a`的下标`k`, 因为我们锁定`[b,c]`这两个数时间复杂度已经到$O(N^2)$,了, 如果再通过遍历来找`k`复杂度会更上一层楼, 为此我们可以引入哈希, 来建立值与下标的映射关系.
  那具体怎么做呢? 我们建立一个`int, int`的哈希, 先把`nums`遍历一遍, 行不行? 很明显, 不行, 那样重复元素不都会选取最后一个的下标吗? 所以很明显不行, 为此我们可以填`dp`, 一边填哈希, 这样一方面不用担心后面的覆盖当前最后面的, 另一方面, 当前最后面的会覆盖前面的, 所以我们拿到的始终是离`b`最近的`a`, 这个还有细节, 我们等会儿再说
- **初始化**
  我们最开始可以给所有值都初始化为2, 因为最小长度就是2, 题目给我们的`nums`长度是大于`2`的, 并且任意两个数都可以构成一个等差子序列, 所以最短的长度就是`2`, 另外, 在状态转移过程中, 我们有很多情况, `dp[i][j]`都会被初始化为`2`, 如果我们一开始就把所有格子都初始化为`2`, 那这些情况就可以不进行处理, 直接略过.
  当然可能存在某些格子, 比如`dp[0][0]`, 很明显, 对于它来说, 长度应该为`1`, 但是我们却把它初始化为`2`, 这会引发问题吗? 答案是不会, 因为我们的`i < j`, 所以根本不会用到`dp`中的所有格子, 实际上, 我们只会用到一小半
  ![image-20250408115239104](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408115239158.png)
- **填表顺序**
  我们的`dp`已经变得很抽象了, 所以我们填表时不应该看`dp`, 而是看`dp`背后的状态表示, 很明显, 我们这里会有两个循环, 它们分别锁定一个`i`位置和一个`j`位置, 我们可以先确定`j`, 对应的是`c`, 再确定`i`, 从`1`号下标遍历到`j-1`, 从`1`开始是因为`0`这个位置前面没有元素, 你顶多长度是`2`, 那不就是最小长度吗, 所以我们略过, 但这样写会有一个问题, 这相当于是`i`在来回跑, 但我们的填表可是有一个hash要填的, 你这样来来回回跑, 那等到`j`更新后, hash里对于重复元素的保存不还是最后一个的下标吗? 所以我们要换个思路, 那就是先锁定`i`, 再锁定`j`, 这样`i`就不会来回跑了, 它一直是往一个方向跑的, 具体做法是, 最外层循环是`i`从`1`开始, 到`n-2`结束(`n-1`其实也没问题), 内层循环是从`j`从`i+1`开始, 一直遍历到`n-1`位置

## 代码编写

```cpp
class Solution {
public:
    int longestArithSeqLength(vector<int>& nums) {
        int n = nums.size(), result = 2;
        vector<vector<int>> dp(n, vector<int>(n,2));
        unordered_map<int, int> hash;
        for(int i = 1; i < n - 1; ++i)
        {
            int b = nums[i];
            hash[nums[i-1]] = i-1;
            for(int j = i + 1; j < n; ++j)
            {
                int c = nums[j];
                int a = 2*b-c;
                if(hash.count(a) == 1)
                {
                    int k = hash[a];
                    if(k < i)  dp[i][j] = dp[k][i] + 1;
                    result = max(result, dp[i][j]);
                }
            }
        }
        return result;
    }
};
```

# 完