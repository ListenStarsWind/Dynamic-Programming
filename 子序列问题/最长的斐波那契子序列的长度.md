# [最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence)

![image-20250408104235638](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408104235759.png)

## 题目解析

如果序列 `X_1, X_2, ..., X_n` 满足下列条件，就说它是 *斐波那契式* 的：

- `n >= 3`
- 对于所有 `i + 2 <= n`，都有 `X_i + X_{i+1} = X_{i+2}`

给定一个**严格递增**的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。

斐波那契式的子序列长度必须大于2, 并且, 从第三个数开始, 它是前面两个元素的和.

**示例一**

>```
>输入: arr = [1,2,3,4,5,6,7,8]
>输出: 5
>解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。
>```

首先我们可以选择`1,2`, 那么下一个元素就应该是`3`, `3`是存在的, 接着根据`2,3`, 得出下一个元素是`5`, 接着是`3,5`得`8`, `8`也存在, 于是就有`[1,2,3,5,8]`

**示例二**

>```
>输入: arr = [1,3,7,11,12,14,18]
>输出: 3
>解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。
>```

先选择`1,3`, 发现没有`4`, 接着选择`1,7`, 发现没有`8`, 于是选择`1,11`, 得到`[1,11,12]`, 接着再从`3`开始, `3,7`, 没有`10`,`3,11`, 有`[3,11,14]`, .........有`[7,11,18]`, 于是返回三

## 算法原理

- **状态表示**
  定义`dp[i]`为以`i`为结尾的所有子序列中, 其中最长的斐波那契子序列长度.
- **状态转移**
  很明显, 我们想要达到的效果是, 在`i`前面找一个位置, 看它们两个能否构成满足要求的子序列, 能构成, 就有`dp[i] = dp[j] + 1`, 但是这里有个问题, 我怎么知道`i`元素接在以`j`为末尾的子序列, 所形成的新子序列, 仍旧是满足要求的呢? 或者, 你该如何仅通过两个数判断它们能不能构成斐波那契子序列的呢? 判断不了呀, 也就是说, 仅靠锁定一个数, 然后遍历另一个数, 这样得到的两个数无法确定一个斐波那契子序列
- 状态表示
  通过锁定一个数, 然后遍历另一个数, 这种方法得到的两个数, 无法确定一个斐波那契数列, 那么, 我锁定两个数, 遍历出一个数, 这样组成的三个数, 能不能确定一个斐波那契子序列呢? 答案是可以的, 假设现在你已经锁定了`[b,c]`这两个数, 那第三个数`a`是`c-b`, 那不就可以构成一个斐波那契子序列吗? 而且, 在确定`[a,b,c]`之后, 无论是向前推, 还是向后推, 都是可以推出来的, 换言之, 这种方案可以确定一个斐波那契子序列
  所以我们定义`dp[i][j]` 表示, `b = nums[i], c = nums[j]`, 以`[b,c]`为结尾的所有子序列中, 其中最长的斐波那契子序列长度, 另外, 由于它是子序列, 所以必有`i < j`
- **状态转移**
  首先我们可以根据锁定的两个数, 直接得出`a`的值`c-b`, 此时, `a`可能存在, 也可能不存在, 对于存在的情况, 还可以根据`a`的位置进一步划分,![image-20250408114150749](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408114151002.png)
  另外我们还可以做个优化, 在寻找a的下标时, 我们可以借助于哈希表, 该哈希表描述了元素值和下标的`pair`, 这样就能更方便地找到`a`的下标
- **初始化**
  我们发现, 很多情况下`dp[i][j]`会被初始化为`2`, 所以我们可以最开始将二维数组中的所有值都定为`2`, 另外需要注意的是, 我们的`dp`不会被全部使用, 因为`i < j`, 所以它实际上只会使用到一半不到
  ![image-20250408115239104](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250408115239158.png)
  尽管像`dp[0][0]`这种格子有一定的实际意义, 而且很明显它对应的值不是2, 但我们用不到, 所以没有影响
- **填表顺序**
  对于`dp[i][j]`, 可能需要`dp[k][i]`, 由于`i < j, k < i`, 所以`k < i, i < j`, 也就是说,`dp[k][i]`在`dp[i][j]`的左上方, 所以我们填表的时候只要满足这一点就行了, 比如, 从左往右, 从上到下
- **返回值**
  返回值需要取`dp`中的最大值, 需要注意的是, 当发现最大值为`2`时, 说明一个斐波那契都构成不了, 依据题意, 这种情况应该返回0

## 代码编写

```cpp
class Solution {
public:
    int lenLongestFibSubseq(vector<int>& arr) {
        int result = 2;
        int n = arr.size(); unordered_map<int,int> hash;
        vector<vector<int>> dp(n, vector<int>(n, 2));
        for(int i = 0; i < n; ++i) hash[arr[i]] = i;
        for(int j = 2; j < n; ++j)
        {
            int c = arr[j];
            for(int i = 1; i < j; ++i)
            {
                int b = arr[i];
                int a = c - b;
                if(a < b && hash.count(a) == 1)
                {
                    int k =hash[a];
                    dp[i][j] = dp[k][i] + 1;
                    result = max(result, dp[i][j]);
                }
            }
        }
        return result < 3 ? 0 : result;
    }
};
```

# 完