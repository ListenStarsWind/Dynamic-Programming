# [组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

![image-20250415110140837](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250415110140958.png)

## 题目解析

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例一**


>输入：nums = [1,2,3], target = 4
>输出：7
>解释：
>所有可能的组合为：
>(1, 1, 1, 1)
>(1, 1, 2)
>(1, 2, 1)
>(1, 3)
>(2, 1, 1)
>(2, 2)
>(3, 1)
>请注意，顺序不同的序列被视作不同的组合。

这道题位于"似包非包"这个子文件夹下, 其意思就是, 有些题目, 看起来很像背包问题, 但其实不能用背包问题的思路去解决, 如果强行使用背包问题的思路, 反而容易出错.(以我们的背包思路来说)

本题有一个很重要的点, 那就是顺序不同的序列被视为不同的组合, 比如在上面的示例中, 背包问题会将"(1,1,2)", "(1,2,1)", "(2,1,1)"归为一种, 因为它不在乎背包里物品的先后顺序, 它只在乎有无, 或者, 更加规范的说, 背包解决的是"组合"问题, "组合"问题不在乎内部元素的相对顺序, 但本题, 尽管它称自己是"组合", 但实际上, 它是一个"排列", "排列"是对于顺序有要求的.

**示例二**


>输入：nums = [9], target = 3
>输出：0

## 算法原理

- **状态表示**

  这道题有一个很让人困惑的点, 那就是不太好找到一个状态连续变化的过程, 找不到这个过程, 我怎么用动规呢? 对于这种情况, 就需要我们根据研究对象特性, 从中发现重复的子问题, 因为这个子问题是重复嵌套的, 所以就可以相互之间联系起来, 构成一个连续的过程.

  由于它有"顺序性"这个强要求, 所以会有严格的"第一个位置", "第二个位置", "第三个位置".....这样的概念, 每个位置都可以从数组中任选一个元素, 因为它是可以重复的.
  ![image-20250415113411882](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250415113412029.png)

  假设我们的`nums`里面的元素是`{a,b,c,d}`(位置的个数是随便画的, 不要在意, 这里假设方案就是四个位子), 这样的话, 就要求这四个位子的数值和为`t`, 如果第一个位置选择`a`, 那么就需要在第二个到第四个位置里填数, 使得这三个位置的数值和为`t-a`, 如果第二个位置你又选了`a`(可以重复选择), 那么接下来要做的, 就是在第三个到第四个位置里填数, 使得它们的和变成`t-a-a`....我们发现, 这都是一个类似的问题, 在某某区间里填数, 使得它们的数值和变成某一个数

  因而, 我们定义`dp[i]`为, 凑成总和为`i`, 一共有多少种排列数

- **状态转移**

  对于最后一个位置来说, 我可以从数组中任选一个元素放进去, 那对于前面`i-1`的状态, 它的目标不就是要凑成`i-nums[j]`的总和吗? 另外由于数组里有多个元素, 所以要把它们累加起来, `dp[i] += dp[i-nums[j]]`, 另外, 这里可以看出`i-nums[j]`有越界可能, 对于负数的`i-nums[j]`来说, 由于数组中的元素都不是负数, 所以它的选法只能值零, 或者说, 你可以直接跳过它.

- **初始化**

  第一个位置`dp[0]`表示凑成`0`有多少种方案, 由于我们的数组元素都是大于等于1的, 所以我们只有什么元素都不选这一种方案, 因而`dp[0] = 1`

- **填表数列**

  从左往右

- **返回值**

  我们要凑成`t`, 所以是`dp[t]`

## 代码编写

尽管题目保证结果不超过`int`, 但中间过程会超过`int`, 因此我们需要对每个格子取模从而防止溢出, 有一个用例是被精心设计过的, 结果正好是`INT_MAX`, 所以这里加一

```cpp
class Solution {
    const uint mod = static_cast<uint>(INT_MAX) + 1;
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<uint> dp(target+1, 0); dp[0] = 1;
        for(int i = 1; i <= target; ++i)
        {
            for(auto e : nums)
                if(i>=e) dp[i] += dp[i-e];
            dp[i] %= mod;
        }
        return dp[target];
    }
};
```

# 完
