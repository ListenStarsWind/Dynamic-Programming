# [回文子串](https://leetcode.cn/problems/palindromic-substrings)

![image-20250409084306330](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409084306453.png)

## 题目解析

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

**示例一**

>```
>输入：s = "abc"
>输出：3
>解释：三个回文子串: "a", "b", "c"
>```

对于`"abc"`来说, 有六个子串, `"a", "b", "c", "ab", "bc", "abc"`, 其中为回文子串的是`"a", "b", "c"`

**示例二**

>```
>输入：s = "aaa"
>输出：6
>解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
>```

具有不同开始位置或结束位置的子串, 即使看起来一模一样, 也会被视为不同的子串, 需要单独计数.

## 算法原理

对于回文子串问题来说, 有三种解决方案, 包括"中心扩展算法", "马拉车算法", "动态规划", 单就时空复杂度来说, "马拉车算法"是最优秀的, "中心扩展算法"排第二, "动态规划"排第三, "中心扩展算法"我们在基础算法篇有过提及, "马拉车算法", 难度高, 并且适用范围很窄, 几乎只能应对回文子串问题, "动态规划"可以保存所有回文子串的信息, 从而将部分回文串困难题直接降级到简单, 而且"动态规划"适用范围很广, 所以"动态规划"应对回文子串问题有它的优势

- **状态表示**
  我们的研究对象是字符串`s`中的回文子串, 要找回文子串首先需要找子串, 而要确定一个子串需要它的首尾位置, 这就涉及到两个数, 所以我们定义`dp[i][j]`为以`i`位置为开始, 以`j`位置为结束的子串是否为回文子串, 如果是, 那值就是`true`, 反之亦然. 需要注意的是, 因为我们是以`i`位置为开始, 以`j`位置为结束的子串, 所以暗含的信息是`i <= j`.为此, 我们的`dp`表实际上只会用到一部分
  ![image-20250409090525870](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409090525976.png)
- **状态转移**
  对于一个子串来说, 它可以被分成两个部分, 一是它的首尾, 二是它首尾中间夹着的那部分
  ![image-20250409090932410](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409090932473.png)
  如果它的首尾两个字符不相同, 意味着什么呢? 意味着它肯定不是回文子串, 所以此时我们就可以把`dp[i][j]`打上`false`, 当首尾两个字符串相同时, 我们就进入了下一步, 如果此时它俩中间夹的那个子串不是回文子串, 那以`[i,j]`为首尾的子串很显然就不是回文子串, 如果中间部分是回文子串, 那么以`[i,j]`为首尾的子串就是回文子串, 所以就有`dp[i][j] = dp[i+1][j-1]`
  接下来我们要处理一个问题, 会不会出现没有中间部分这一情况呢? 当然是有的, 比如整个子串就一个字符, `i,j`指向同一个位置, 亦或者整个子串就两个字符, `i,j`指向相邻位置, 
  ![image-20250409091704921](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409091704997.png)
  对于这种情况, `[i+1][j-1]`就会发生越界, 因而我们要特殊处理, 要知道, 我们现在说的都是建立在首尾字符相等的前提下进行的, 对于只有两个字符的, 如果它首尾字符相同, 很明显, 它也是回文子串, 而对于一个字符的, 那就不用说了, 它天然就是回文子串.
  判断是否存在越界也很简单, 比较`i+1`和`j`的相对大小就行了, 如果`i+1 < j`, 就说明中间是夹着子串的.
- **初始化**
  我们的`dp`是一个二维布尔数组, 要么初始化成全`true`, 要么全是`false`, 那我们就全`false`了, 这样我们只要看`s[i] == s[j]`这个分支就行了, 另一个分支`s[i] != s[j]`, 可以直接使用初始化的`false`, 从而可以直接跳过, `bool`默认构造是`false`, 所以也不用明着写
- **填表顺序**
  因为对于`[i,j]`来说我们可能要用到`[i+1, j-1]`位置, 所以我们的填表顺序应该是从下往上, 对应状态表示的那张图, 看的会更真切
- **返回值**
  `dp`表中存着所有子串的信息, 我们只需遍历一下, 累加为`true`的个数即可.

## 代码编写

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size(), result = 0;
        vector<vector<bool>> dp(n, vector<bool>(n));
        for(int i = n - 1; i >= 0; --i)
        {
            for(int j = i; j < n; ++j)
            {
                if(s[i] == s[j])
                    dp[i][j] = i + 1 < j ? dp[i+1][j-1] : true;
                if(dp[i][j]) ++result;
            }
        }
        return result;
    }
};

/*
    本题所使用的动态规划是间接的, 间接的意思是不直接对题干中的需求进行直接分解, 
    化为小问题, 进行解答间接有两种级别, 依据离原题目要求的远近程度可以分为两个
    级别, 第一个级别, 离原题目的关系还比较近, 比如本题就是这一级别. 本题要求的
    是字符串的某种组成, 这里就是子串, 所有的子串中, 有多少种子串是符合要求的
    我们不直接进行化解, 就是定义dp的什么什么(比如某个二维坐标确定一个区间, 表示
    这个区间的子串)里有多少种满足要求的子串个数, 如果这样定义的话, 会面临一个很难
    处理的去重问题, 如果这样做的话, 我们可能会定义dp[i]表示[0,i]这个子串里还有多少
    个子子串是满足要求的, 此时一种思路就是先在[0,i]区间找一个j, 使[j,i]是回文串, 此时
    [j,i]这个回文串就是一, 在加上dp[j-1]就可以了, 但这种思路存在一个问题, 那就是可能存在
    一个j_z, j_z是小于j的, 并且[j_z, i]也是回文串, 那不就少考虑了这个回文串, 为了把他也
    考虑进来, 你需要让j往前面遍历, 但此时, 就会引发重复问题, dp[j]中包含dp[j_z]的子串, 该
    如何去重, 去不了, 所以我们使用间接的方式, 我们通过动规的形式穷举所有子串, 如果子串满足
    要求就标记一下, 最后计数一下有多少标记即可
    第二种级别的间接就和原题目完全不是一个性质的问题, 比如可能用了正难则反, 但和原题目直接
    存在某种转化关系
*/
class Solution {
public:
    int countSubstrings(string s) {
        int dp[1000][1000] = {0};

        int res = 0;
        int n = s.size();
        for(int i = n-1; i >= 0; --i)
        {
            for(int j = i; j < n; ++j)
            {
                if((s[i] == s[j]) && (i+1>j-1 || dp[i+1][j-1]))
                {
                    ++res;
                    dp[i][j] = 1;
                }
            }
        }

        return res;
    }
};
```

# 完