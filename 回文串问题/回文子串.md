# [回文子串](https://leetcode.cn/problems/palindromic-substrings)

![image-20250409084306330](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409084306453.png)

## 题目解析

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

**示例一**

>```
>输入：s = "abc"
>输出：3
>解释：三个回文子串: "a", "b", "c"
>```

对于`"abc"`来说, 有六个子串, `"a", "b", "c", "ab", "bc", "abc"`, 其中为回文子串的是`"a", "b", "c"`

**示例二**

>```
>输入：s = "aaa"
>输出：6
>解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
>```

具有不同开始位置或结束位置的子串, 即使看起来一模一样, 也会被视为不同的子串, 需要单独计数.

## 算法原理

对于回文子串问题来说, 有三种解决方案, 包括"中心扩展算法", "马拉车算法", "动态规划", 单就时空复杂度来说, "马拉车算法"是最优秀的, "中心扩展算法"排第二, "动态规划"排第三, "中心扩展算法"我们在基础算法篇有过提及, "马拉车算法", 难度高, 并且适用范围很窄, 几乎只能应对回文子串问题, "动态规划"可以保存所有回文子串的信息, 从而将部分回文串困难题直接降级到简单, 而且"动态规划"适用范围很广, 所以"动态规划"应对回文子串问题有它的优势

- **状态表示**
  我们的研究对象是字符串`s`中的回文子串, 要找回文子串首先需要找子串, 而要确定一个子串需要它的首尾位置, 这就涉及到两个数, 所以我们定义`dp[i][j]`为以`i`位置为开始, 以`j`位置为结束的子串是否为回文子串, 如果是, 那值就是`true`, 反之亦然. 需要注意的是, 因为我们是以`i`位置为开始, 以`j`位置为结束的子串, 所以暗含的信息是`i <= j`.为此, 我们的`dp`表实际上只会用到一部分
  ![image-20250409090525870](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409090525976.png)
- **状态转移**
  对于一个子串来说, 它可以被分成两个部分, 一是它的首尾, 二是它首尾中间夹着的那部分
  ![image-20250409090932410](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409090932473.png)
  如果它的首尾两个字符不相同, 意味着什么呢? 意味着它肯定不是回文子串, 所以此时我们就可以把`dp[i][j]`打上`false`, 当首尾两个字符串相同时, 我们就进入了下一步, 如果此时它俩中间夹的那个子串不是回文子串, 那以`[i,j]`为首尾的子串很显然就不是回文子串, 如果中间部分是回文子串, 那么以`[i,j]`为首尾的子串就是回文子串, 所以就有`dp[i][j] = dp[i+1][j-1]`
  接下来我们要处理一个问题, 会不会出现没有中间部分这一情况呢? 当然是有的, 比如整个子串就一个字符, `i,j`指向同一个位置, 亦或者整个子串就两个字符, `i,j`指向相邻位置, 
  ![image-20250409091704921](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409091704997.png)
  对于这种情况, `[i+1][j-1]`就会发生越界, 因而我们要特殊处理, 要知道, 我们现在说的都是建立在首尾字符相等的前提下进行的, 对于只有两个字符的, 如果它首尾字符相同, 很明显, 它也是回文子串, 而对于一个字符的, 那就不用说了, 它天然就是回文子串.
  判断是否存在越界也很简单, 比较`i+1`和`j`的相对大小就行了, 如果`i+1 < j`, 就说明中间是夹着子串的.
- **初始化**
  我们的`dp`是一个二维布尔数组, 要么初始化成全`true`, 要么全是`false`, 那我们就全`false`了, 这样我们只要看`s[i] == s[j]`这个分支就行了, 另一个分支`s[i] != s[j]`, 可以直接使用初始化的`false`, 从而可以直接跳过, `bool`默认构造是`false`, 所以也不用明着写
- **填表顺序**
  因为对于`[i,j]`来说我们可能要用到`[i+1, j-1]`位置, 所以我们的填表顺序应该是从下往上, 对应状态表示的那张图, 看的会更真切
- **返回值**
  `dp`表中存着所有子串的信息, 我们只需遍历一下, 累加为`true`的个数即可.

## 代码编写

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size(), result = 0;
        vector<vector<bool>> dp(n, vector<bool>(n));
        for(int i = n - 1; i >= 0; --i)
        {
            for(int j = i; j < n; ++j)
            {
                if(s[i] == s[j])
                    dp[i][j] = i + 1 < j ? dp[i+1][j-1] : true;
                if(dp[i][j]) ++result;
            }
        }
        return result;
    }
};
```

# 完