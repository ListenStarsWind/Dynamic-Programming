# [分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

![image-20250409143319354](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409143319433.png)

## 题目解析

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文串。

返回符合要求的 **最少分割次数** 。

**示例一**

>```
>输入：s = "aab"
>输出：1
>解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
>```

最差情况就是每个字符单成一个回文子串, `"a", "a", "b"`, 但很明显, 这里有更好的方案, 那就是分割为`"aa", "b"`, 分割次数为一, 返回1.

**示例二**

>```
>输入：s = "a"
>输出：0
>```

如果字符串本身就是回文, 那就不同切, 这样, 切割次数就是0

**示例三**

>```
>输入：s = "aaba"
>输出：1
>```

可以`"aa", "b", "a"`, 分割次数为二, 也可以`"a", "aba"`, 分割次数为1

## 算法原理

- **状态表示**
  对于一个子串来说, 它可以分成两个部分, 前面部分, 记为`[0,j-1]`区域, 可以被拆分成回文子串, 后面区域`[j,1]`区域能自成一个回文串, 这样, 对于以`i`为结尾的子串来说, 它的划分 次数就是前面的划分次数再加上划分前面和后面这两个部分的分割次数, 因而, 我们可以定义`dp[i]`为以`0`为起始位置, 以`i`为结束位置的最小划分次数.
  ![image-20250409144850597](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250409144850641.png)
- **状态转移**
  对于以`0`为开始, 以`i`为结尾的子串来说, 首先它本身可能就是回文的, 此时划分次数是0, 无疑, 零是最小的, 所以我们就不用再多花功夫, 把它划分成前面后面两个部分细细考虑, 但如果它本身不是回文子串, 此时就需要进行再划分, 
  首先我们要确定一下`j`的范围, 因为我们所说的都是建立在可被划分的前提下, 所以这就要求`[0,j-1], [j,i]`这两个子串是有意义的, 所以`0 < j <= i`,  当`[j,i]`是回文串, 那我们就找到一个可行的方案, 对于此时的方案来说, 其最小的划分次数就是前面最小的划分次数再加上一, 前面的最小划分次数就是`dp[j-1]`, 然后`j`的位置是在不断调整的, 所以可能会有多个可行方案, 我们就需要选择其中最小的
  为了判断某个子串是否是回文, 我们需要在填`dp`前, 把所有可能子串的状态都统计出来, 以便于我们快速判断某个子串是否是回文的
- **初始化**
  我们的`j`不会越界, 所以不用初始化, 从另一种角度来说, `j`为`0`的情况其实就是对`[0,i]`进行整体判断, 如果它是回文, 那次数就是零, 如果不是回文, 在划分成两个部分的过程中也求出来了
  为了避免`dp`的初始化干扰我们的大小比较, 我们可以最开始将它们初始成最大值, 这样当格子中的原始值与可行方案的划分次数进行比较时, 划分次数一定是小的, 所以就会舍弃原始值
- **填表顺序**
  为了`dp[i]`我们可能需要`dp[j-1]`的值, 所以填表顺序应该是从左往右
- **返回值**
  题目要的就是整个字符串的最小划分次数, 这其实就是`dp[n-1]`, 直接返回即可

## 代码编写

```cpp
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        vector<vector<bool>> isPal(n, vector<bool>(n));
        for(int i = n-1; i >= 0; --i)
        {
            for(int j = i; j < n; ++j)
            {
                if(s[i] == s[j])
                    isPal[i][j] = i + 1 < j ? isPal[i+1][j-1] : true;
            }
        }

        vector<int> dp(n, INT_MAX);
        for(int i = 0; i < n; ++i)
        {
            if(isPal[0][i])
                dp[i] = 0;
            else
            {
                for(int j = 1; j <= i; ++j)
                {
                    if(isPal[j][i])
                        dp[i] = min(dp[i], dp[j-1] + 1);
                }
            }
        }
        return dp[n-1];
    }
};

/*
    思路: 含有预处理的动态规划 
    check数组负责以常数时间级别判断某个区间(左闭右闭)是否是回文串区间
    定义dp[i]表示[0,i]区间的子串进一步划分, 其子串全部为回文串的最小次数
    极端分析, 最极端的情况下, 需要把这个[0,i]子串全部分解为一个个的单独字符
    此时的分解次数恰好就是下标次数
*/
class Solution {
public:
    int minCut(string s) {
        int check[2000][2000] = {0};

        int n = s.size();
        for(int i = n-1; i >= 0; --i)
        {
            for(int j = i; j < n; ++j)
            {
                // 首先首尾的两个字符很明显需要相等
                // 存在两种特殊的首尾
                // 一是ij相等, 此时会命中 i+1 > j-1
                // 二是ij相邻, 此时也会直接命中
                // 也就是说, 对于上述两种(i+1>j-1)情况, 
                // 本质上只需要首尾相等这一个要求
                if((s[i] == s[j]) && (i + 1 > j - 1 || check[i+1][j-1]))
                    check[i][j] = 1;
            }
        }

        int dp[2000] = {0};
        for(int i = 0; i < n; ++i)
        {
            if(check[0][i] == 1) continue;
            int def = i;
            for(int j = 0; j < i; ++j)
            {
                if(check[j+1][i] == 1)
                    def = min(def, dp[j] + 1);
            }
            dp[i] = def;
        }

        return dp[n-1];
    }
};
```

# 完