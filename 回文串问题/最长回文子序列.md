# [最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence)

![image-20250410083350730](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410083350817.png)

## 题目解析

这回我们找最长子**序列**, 而不是子**数组**.   在字符串`s`中, 找出其中最长的回文子序列, 并返回它的长度.

**示例一**

>```
>输入：s = "bbbab"
>输出：4
>解释：一个可能的最长回文子序列为 "bbbb" 。
>```

`a`只有一个, 如果要成为回文子序列, 只能自己单成一个, 所以我们跳过`a`, 就得到了`bbbb`, 长度为4

**示例二**

>```
>输入：s = "cbbd"
>输出：2
>解释：一个可能的最长回文子序列为 "bb" 。
>```

**示例三**

>```
>输入：s = "ababca"
>输出：5
>解释：一个可能的最长回文子序列为 "ababa" 。
>```

## 算法原理

- **状态表示**
  我们先按照惯性, 定义`dp[i]`为以`i`位置元素为结尾的所有子序列中, 最长回文子串的长度.
  我们想要的是, 利用`i`与`i-1, i-2, i-3....`元素的关系, 从而判断以`i-1, i-2, i-3`结尾的最长回文子序列后面能不能再接一个`i`位置元素, 从而构成一个更长的回文子序列, 但以`i-1, i-2, i-3...`为结尾的最长回文子序列后面再接上`i`能不能再构成回文子序列? 我们的回答是, 它大概率是不能的, 对于一个长度超过`1`的回文子序列来说, 往里面放一个落单的字符, 就会破坏原有的回文性, 都破坏回文性了, 那还讨论什么呢? 而且我们也无法依据`i`元素与`i-1, i-2, i-3...`元素的关系(对于字符来说, 无非是等于不等于), 去确定接上`i`字符之后, 新形成的子序列是否是回文的, 所以我们的状态表示是有误的.
  既然移位不够用, 我们就上二维, 我们可以感受到一个明显到的事实, 如果一个子序列本身就是回文的, 那它两端再加一个相同的字符依旧是回文的, 而对于一个子序列可以通过一段区间来进行约束, 所以, 我们定义`dp[i][j]`为`[i,j]`区间里, 最长回文子序列的长度

- **状态转移**
  对于`[i,j]`区间来说, 最好的情况就是`i, j`位置的两个元素相同, 这样就是`[i+1, j-1]`区间的最长回文子序列长度加上二了, 但我们先打住, 这个`[i+1, j-1]`会不会越界呀, 当然是可能的,存在两种情况, 一是, `i, j`相等, 此时一加一减不就越界了吗?   另外的一种情况是`i, j`相邻, 此时一加一减就相当于互换了位置                                 对于第一种情况, 此时的回文子序列长度其实就是一, 而对于第二种情况, 此时的回文子序列长度就是2.
  ![image-20250410091955432](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410091955553.png)

  如果不相等, 那么它们一定不能同时作为回文子串的首尾, 但可能分别作为, 取其中的最大值
  ![image-20250410093447553](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410093447616.png)

- **初始化**
  由于`i <= j`所以, 我们实际使用的格子只有这些
  ![image-20250410094129717](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410094129783.png)
  首先那个`dp[i+1][j-1]`我们已经内部判断过了, 所以不用考虑越界, 接下来只需要考虑`dp[i][j-1], dp[i+1][j]`, 我们发现只有对角线上的格子存在越界风险, 对角线格子代表`i == j`的情况, 对于`i == j`的情况, 一定会有`s[i] == s[j]`从而被初始化为`1`, 所以仍旧不会越界, 等会儿我们可以把这种情况提到外面, 单独初始化.

- **填表顺序**
  我们发现, 对于一个格子来说, 它的初始化有可能用到其左边和下边的格子, 为此, 我们需要从上往下, 从左往右填表

- **返回值**
  题目要我们求`s`字符串中的最长回文子序列, 也就是在`[0,n-1]`区间中找最长的回文子序列, 即`dp[0][n-1]`

## 代码编写

在写代码的时候其实可以把`i + 1 = j `的情况并入`others`, 因为`i + 1 = j`的位置其实是这样的, 与之对应的格子恰好是不使用的格, 它们一直都是0, 所以不会对状态转移产生影响

![image-20250410095543295](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410095543371.png)

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for(int i = n-1; i >= 0; --i)
        {
            dp[i][i] = 1;
            for(int j = i + 1; j < n; ++j)
            {
                if(s[i] == s[j]){
                    dp[i][j] = dp[i+1][j-1] + 2;
                }
                else{
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
};
```

# 完