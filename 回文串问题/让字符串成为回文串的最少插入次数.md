# [让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

![image-20250410102649650](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410102649733.png)

## 题目解析

给你一个字符串 `s` ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 `s` 成为回文串的 **最少操作次数** 。

**示例一**

>```
>输入：s = "zzazz"
>输出：0
>解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。
>```

如果一个字符串本身就是回文的, 那就不需要插入任何一个字符.

**示例二**

>```
>输入：s = "mbadm"
>输出：2
>解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。
>```

似乎可以以`a`为对称中心, 这样的话`m b! a d! m`中的`b, d`是无法配对的, 所以可以在`a`旁边加个`b`, `m b a b d! m `, 然后再在`b`旁边加个`d`, `m d b a b d m`

**示例三**

>```
>输入：s = "leetcode"
>输出：5
>解释：插入 5 个字符后字符串变为 "leetcodocteel" 。
>```

## 算法原理

- **状态表示**
  状态表示到目前无非这几种, 以`i`位置为结尾, 以`i,j`位置为结尾, 以`i,j`位置为起始, 以`i,j`位置为区间, 在这里, 我们选一个合适的, 那就是以`[i,j]`位置为起始, 定义`dp[i][j]`为以`i`位置为起始, 以`j`位置为结束, 所形成的子串中, 要变为回文串的最小插入次数.
- **状态转移**
  较好的一种情况是`s[i] == s[j]`, 此时, 最起码`i, j`这两个位置不需要我们操心, 所以接下来我们只需要让以`i+1`位置为起始, 以`j-1`位置为结束的这个子串变成回文串就行了, 要把它变成回文串可能需要插入一定次数的字符, 由于我们要的是最小次数, 所以我们应该选择其中最小的, 那么以`i+1`位置为开始, 以`j-1`位置为结尾的子串变成回文子串的最少插入次数是多少呢? 这不正好和我们的状态表示呼应上了吗? , 这就是`dp[i+1][j-1]`, 所以就能得到`dp[i][j] = dp[i+1][j-1]`,                    不过我们需要注意的是, 可能并没有以`i+1`位置为开始, 以`j-1`位置为结尾的区间, 有两种情况, 一是`i,j`就是同一个位置, 他本身就是回文串, 所以插入次数为零, 另外的一种情况是, `i,j`位置相邻, 对于这种情况, 由于它是建立在`s[i] == s[j]`前提下的, 所以其本身然就是回文子串, 插入次数为零.
  当`s[i] != s[j]`时, 我们就需要把差上的给补上, 对此我们有两种情况, 一是把`s[i]`补到`j`右边, 然后保证`i+1,j`位置是回文的, 二是把`s[j]`补到`i`左边, 然后保证`i, j-1`位置是回文的, 也就是说, 有`dp[i+1][j] + 1, dp[i][j-1] + 1`, 我们要选取其中最小的那个.
  ![image-20250410112021018](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410112021146.png)
- **初始化**
  对于`[i+1, j-1]`区间不合法的情况, 我们已经有相应的应对方案, 所以无需考虑, 接下来只要考虑`dp[i+1][j], dp[i][j-1]`, 有两条对角线需要考虑
  ![image-20250410112150482](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410112150555.png)
  不过其实我们不用考虑更长的对角线, 因为对于它们来说, ` i == j, s[i] == s[j]`, 我们只需要考虑更小的对角线, 但其实我们不需要考虑, 因为它们的左边下边都是被使用的格子, 不会越界.
  综上, 我们可以不进行初始化操作, 另外, 不进行初始化还有一个好处, 那就是不初始化默认为零, 因此, `[i+1, j-1]`区间不合法的两种情况可以直接略过, 因为它们就是零
- **填表顺序**
  对于某个`dp`来说, 它可能要用到左边和下边的格子, 所以顺序应该为从左往右, 从下往上
- **返回值**
  我们要的是整个字符串的最小插入次数, 对应区间为`[0, n-1]`

## 代码编写

```cpp
class Solution {
public:
    int minInsertions(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for(int i = n -1; i >= 0; --i)
        {
            for(int j = i + 1; j < n; ++j)
            {
                if(s[i] == s[j]) dp[i][j] = dp[i+1][j-1];
                else dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1;
            }
        }
        return dp[0][n-1];
    }   
};
```

# 完