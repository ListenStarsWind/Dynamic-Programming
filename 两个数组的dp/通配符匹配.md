# [通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

![image-20250411110911757](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411110911877.png)

## 题目解析

给你两个字符串, `s`和`p`, 请你确认它们是否可以被视为等效的字符串. `p`中可能会含有例如`'?'`或者`'*'`这样的通配符. 其中`'?'`可以匹配任意单字符, `*`可以匹配任意字符串, 包括空串. 如果这两个字符串等效, 那就返回`true`, 不等效就返回`false`

**示例 1：**

>输入：s = "aa", p = "a"
>输出：false
>解释："a" 无法匹配 "aa" 整个字符串。

`p`中只有一个字符`a`, 这个`a`只能匹配`s`中的某一个`a`, 剩下的那个无法匹配, 所以是不等效的

**示例二:**

> 输入：s = "aa", p = "\*"
> 输出：true
> 解释：'\*' 可以匹配任意字符串。

`'*'`可以匹配任何任何字符串, 或者你也可以认为它可以匹配任意字符, 并且匹配完后不用将自己去除, 比如`*`可以匹配最后一个`a`, 并且不把自己删除, 于是变成`s = "a", p = "*"`, 它接着匹配剩下的`a`, 变为`s = "", p = "*"`, 并且它还可以匹配空串, 这样就可以全部匹配, 所以输出true.

**示例三:**


>输入：s = "cb", p = "?a"
>输出：false
>解释：'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。

**示例四:**

>输入：s = "adceb", p = "*a\*b"
>输出：true
>解释：'\*'可以匹配'a'前面的空串, 'a'匹配'a', '\*'可以匹配"bce", 'b'匹配'b'

## 算法原理

- **状态表示**
  题目问我们两个字符串是否可以完全匹配, 但直接匹配太难了, 所以我们可以先从两个字符串中取出一个子串, 比较子串是否可以完全匹配, 之后通过不断地把子串增长, 从而营造出动态发展的过程.   为此, 我们可以先以`s`的`[0,i]`区间为从`s`中取出的子串, 然后再以`p`的`[0,j]`区间为从`p`中取出的子串, 然后比对这两个子串是否能完全匹配, 若能, `dp[i][j]`定义为`true`, 否, 则定义为`false`
  ![image-20250411122238889](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411122238957.png)
- **状态转移**
  还是老样子, 我们通过分析最后一个位置的状况, 分情况进行讨论. 
  `s[i]`就是普通字符, 没什么好讨论的, 所以我们以`p[j]`为切入点, 它有三种情况, 分别是为普通字符, 为`?`, 为`*`
  首先分析普通字符这种情况. 首先如果要确保`s, p`中取出的子串可以完全匹配, 首先要满足的是它们的最后一个位置能否匹配, 即`s[i] == s[j]?`, 如果匹配了, 还要前面的也能匹配, 所以`[0,i-1]`和`[0,j-1]`这两段区间也要能匹配, 故而该种情况的推导方程为`dp[i][j] == s[i] == p[j] && dp[i-1][j-1]`
  然后是`?`, `?`可以匹配任意单个字符, 这意味着`s[i]`匹配身为`?`的`p[j]`, 那么此时只要前面的也能完全比配就行了, `dp[i][j] = dp[i-1][j-1]`
  最后是`*`, 对于`*`, 由于可以匹配任意字符串, 所以我们还要依据它匹配的字符串长度去进一步地进行分类讨论
  首先`*`可以匹配一个空串, 此时`s`剩下的区间就是`[0,i]`, 而`p`剩下的区间就是`[0,j-1]`, 即`dp[i][j-1]`
  `*`当然也可以匹配一个长度为一的字符串, 这样`s`剩下的就是`[0,i-1]`, `p`剩下的就是`[0,j-1]`, 即`dp[i-1][j-1]`
  当然也可以匹配一个长度为二的字符串, 这样`s`剩下的就是`[0,i-2]`, `p`剩下的就是`[0,j-1]`, 即`dp[i-2][j-2]`
  ......
  很明显, 这是一个循环, 我们只要这个循环中的一个分支成立, 那整体就成立, 也就是说, 对于`*`这种情况的种种分支来说, 它们之间是或的关系, 这个循环的时间复杂度是$O(N)$, 外面动规的时间复杂度是$O(N^2)$, 所以它们两个一乘就变成了$O(N^3)$, 这个复杂度太高了, 下面我们需要把`*`这种情况简化为常数级别. 
  有两种方案, 一是用数学把它化简
  对于`dp[i][j]`有`dp[i][j] = dp[i][j-1] || dp[i-1][j-1] || dp[i-2][j-1].....`
  而对于`dp[i-1][j]`有`dp[i-1][j] = dp[i-1][j-1] || dp[i-2][j-1] || dp[i-3][j-1]....`
  它俩合并就有`dp[i][j] = dp[i][j-1] || dp[i-1][j]`
  第二种方法, 是认为`*`的匹配,模式有两种, 第一种是, 可以匹配任意字符, 且匹配之后不将自己去除,
  在这种逻辑的引导下, `*`现在只能匹配一个字符, 但匹配完后自己仍能发挥作用, 所以`*`可以先把最后一个字符匹配掉, 这样剩下的就是`[0,i-1]`和`[0,j]`, 即`dp[i-1][j]`, 这个`dp[i-1][j]`我们不用管, 之前已经初始化过了
  第二种是, `*`直接匹配空字符串, `*`遇到空字符串会将自己去除, 这样剩下的就是`[0,j-1]`和`[0,i]`, 即`dp[i][j-1]`
  两种方案只要有一个能走通就行, 所以`dp[i][j] == dp[i-1][j] || dp[i][j-1]`
- **初始化**
  根据状态表示, 我们意识到, 对于一个格子来说, 它可能需要左边的格子`dp[i][j-1]`, 左上角的格子`dp[i-1][j]`, 所以对于第一行和第一列来说, 它们可能越界, 为了防止这种情况的发生, 我们可以引入虚拟位置, 将虚拟位置视为`s,p`中的某个子串为空串的情况.
  ![image-20250411131655583](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411131655640.png)
  为此我们需要对虚拟位置进行初始化, 此时对于`[0,0]`来说, 就相当于两个子串都是空的, 当然可以匹配, 所以为`true`, 对于第一行的其它内容来说, 它代表的是`s`为空串的情况, 空串只有`*`可以匹配, 且匹配完后需要将自己去除, 记`*`位于`k`位置, 那在`*`与空串同归于尽之后, 就需要依据`k-1`的位置来判断`k`位置是否能够匹配. 
  对于那一列剩下的部分来说, 由于`p`中没有字符, 所以无法匹配. 
  另外注意下标映射关系
- **填表顺序**
  对于某个格子来说, 可能需要左边和左上角的格子, 所以顺序为从左往右, 从上往下
- **返回值**
  题目要完全匹配, 此时的区间就是整个`s, p`, 对应最右下角的格子

## 代码编写

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        vector<vector<bool>> dp(m+1, vector<bool>(n+1));
        dp[0][0] = true;
        for(int i = 1; i <= n; ++i) 
            dp[0][i] = p[i-1] == '*' && dp[0][i-1];
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {   
                if(p[j-1] == '*') dp[i][j] = dp[i][j-1] || dp[i-1][j];
                else dp[i][j] = (p[j-1] == '?' || p[j-1] == s[i-1]) && dp[i-1][j-1];

                // char key = p[j-1];
                // if(key >= 'a' && key <= 'z')
                //     dp[i][j] = s[i-1] == p[j-1] && dp[i-1][j-1];
                // else if(key == '?')
                //     dp[i][j] = dp[i-1][j-1];
                // else
                //     dp[i][j] = dp[i][j-1] || dp[i-1][j];
            }   
        }
        return dp[m][n];
    }
};
```

# 完
