# [交错字符串](https://leetcode.cn/problems/interleaving-string/)

![image-20250412094347582](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412094347719.png)

## 题目解析

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- **交错** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**注意：**`a + b` 意味着字符串 `a` 和 `b` 连接。

**示例一**

![img](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)


>输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
>输出：true

**示例二**


>输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
>输出：false

**示例三**


>输入：s1 = "", s2 = "", s3 = ""
>输出：true

虽说题目提到了交错这个词, 但实际上我们不必考虑它, 因为也就只有`s1`和`s2`这两个字符串, 所以拼出`s3`和子串不是`s1`, 就是`s2`的, 所以说它们是天然交错的, 因而不用考虑, 即使出现类似于`s1 = "", s2 = "b", s3 = "b"`的情况, 也可以认为是`s1`中取出一个空串, `s2`中取出一个`"b"`, 交替形成`s3`的

## 预处理

这里的字符串有三个, 比较多. 我们还是老样子, 从`s1`和`s2`中各取出一个子串, 比如, 可以把`s1`的`[0,i]`区间和`s2`的`[0,j]`区间取出来做子串, 这样它们拼接出来的子串长度必然是`i+j+2`, 对应的`s3`区间是`[0, i+j+1]`, 但这下标修正太让人难受了, 所以我们在正式操作前, 需要对这三个字符串都进行修正, 在前面都加上一个`" "`占位符, 这样这三个字符串的有效下标都是从`1`开始的, 这样, 如果要取出`s1`的`[1,i]`区间和`s2`的`[1,j]`区间子串, 那么它们拼出的子串长度必然是`i+j`, 对应的`s3`区间为`[0, i+j]`

## 算法原理

- **状态表示**

  定义`dp[i][j]`表示, 从`s1`的`[1,i]`区间中取出的子串, 和从`s2`的`[1,j]`区间中取出的子串, 能否拼接凑成`s3`的`[1, i+j]`

  ![image-20250412102742809](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412102742871.png)

- **状态转移**

  首先, 可以确定的是, 如果它们真的可以拼接成功, 那么对于`s3[i+j]`来说, 它要么是`s1[i]`, 要么是`s2[j]`, 

  假如`s3[i+j] == s1[i]`, 那么剩下的区间就是`[0,i-1]`和`[0,j]`, 所以我们就要看这俩个区间能不能拼出`s3`的`[0, i+j-1]` ,即`s1[i] == s3[i+j] && dp[i-1][j]`, 同理, 如果是和`s2[j]`相等, 那么有`s2[j] == s3[i+j] && dp[i][j-1]`

- **初始化**

  很明显, 因为推导某一个格子的时候, 可能会需要它左边或者上边的格子, 所以我们需要引入虚拟位置, 多加一行和一列. 接下来, 我们值需要关心一下虚拟位置的初始化就行, 因为字符串已经被修正过了, 所以不必担心下标映射关系

  对于`[0,0]`来说, 就是用两个空串拼出一个空串, 很明显, 这是可以拼出的, 所以`dp[0][0] = true`, 接下来, 对于其它的虚拟位置, 都代表一个子串和一个空串拼出一个子串, 比如对于第一行来说, 对应的是`s1`为空串, 所以纯粹是`s2`和`s3`进行比较, 只有它俩完全相同才为`true`, 不过我们也可以在这里来个小动规, 首先要让它们相同, 首先要末尾字符相同, 其次, 要剩下的区间要相同, 这样才能相同

  ![image-20250412104049603](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412104049648.png)

- **填表顺序**

  从左往右, 从上往下

- **返回值**

  要我们判断整个`s1, s2`, 能不能拼出`s3`, 所以对应的格子就是最右下角的位置

## 代码编写

需要注意的是, 在正式处理之前, 我们先要进行一下特别处理, 看看`s1.size() + s2.size() == s3.size()?`, 因为我们的逻辑都是建立在字符数量对得上的假设下进行的, 并且如果假设不成立, 也不用执行后续处理, 直接可以认为无法拼成

```cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int m = s1.size(), n = s2.size();
        if(m + n != s3.size()) return false;
        s1 = " " + s1; s2 = " " + s2; s3 = " " + s3;  
        vector<vector<bool>> dp(m+1, vector<bool>(n+1));
        dp[0][0] = true;
        for(int i = 1; i <= m; ++i) dp[i][0] = s1[i] == s3[i] && dp[i-1][0];
        for(int j = 1; j <= n; ++j) dp[0][j] = s2[j] == s3[j] && dp[0][j-1];
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                dp[i][j] = (s1[i] == s3[i+j] && dp[i-1][j]) || (s2[j] == s3[i+j] && dp[i][j-1]);
            }
        }
        return dp[m][n];
    }
};
```

# 完
