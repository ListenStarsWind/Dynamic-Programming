# [不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

![image-20250411085044977](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411085045143.png)

## 题目解析

给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 1e9 + 7 取模。

**示例一**

>输入：s = "rabbbit", t = "rabbit"
>输出：3
>解释：
>如下所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
>**rabb**b**it**
>**ra**b**bbit**
>**rab**b**bit**

**示例二**

>输入：s = "babgbag", t = "bag"
>输出：5
>解释：
>如下所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
>**ba**b**g**bag
>**ba**bgba**g**
>**b**abgb**ag**
>ba**b**gb**ag**
>babg**bag**

## 算法原理

- **状态表示**
  既然我们要从`s`中找出一个子序列, 使之与`t`相同, 那么我首先要从`s`里面找出一个子序列, 从`t`里面找出一个子串, 随着子串的不断叠加, 最终得到整个`t`, 这样就有了一个连续的状态迁移过程, 我们就能使用动规进行分析. 故而, 我们定义`dp[i][j]`为在`s`的`[0,i]`区间中的所有子序列, 与`t`从`0`开始, 从`j`结束的这个子串,   相同的个数.
  ![image-20250411093140049](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411093140225.png)
- **状态转移**
  因为我们的`s`要的是子序列, 而`t`要的是子串, 子串是确定的, 所以不好下手, 因此我们拿子序列开刀, 因为子序列可以不连续, 它可以跳着取元素, 所以是不确定的, 不确定的, 我们就可以分情况讨论. 最后把各个情况获得的点数相加就行.
  第一种情况, 是`s`的子序列中包含`s[i]`, 这意味着`s`的子序列一定是以`s[i]`为结尾的, 而我们又要找相等的, 这意味着, 如果`t`的子序列末尾不是`s[i]`, 也就是`t[j]`不是`s[i]`, 那么这种方案就不可行, 获得的点数是零, 而如果`s[i] == t[j]`, 那么不就是在`s`的`[0,i-1]`区间里找一个子序列, 使得其与`t`的`[0,j-1]`子串相等吗? 这种情况的个数就是`dp[i-1][j-1]`
  第二种情况, 就是`s`的子序列中不包含`s[i]`, 此时我们只能在`s`的`[0,i-1]`区间里的子序列找和`t`的`[0,j]`区间子串相等的, 对于这种情况的个数, 就是`dp[i-1][j]`
- **初始化**
  根据我们的状态转移, 我们意识到, 在状态转移过程中, 我们需要上面临近的格子`dp[i-1][j]`和左上角的相邻格子`dp[i-1][j-1]`, 所以对于第一行和第一列来说, 会有越界的风险
  ![image-20250411095228904](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411095228966.png)
  为此我们可以在原始`dp`表的上边和左边多加一行和一列.   因为我们引入了虚拟位置, 所以有两点需要注意, 一是要对虚拟位置进行初始化, 我们可以直接通过`dp`表的意义来对虚拟位置进行初始化, 对于多出来的那一列,  可以认为此时的`t`是一个空串, 因为对于任意字符串来说, 空串都是它的子序列, 所以这一行应该初始化为`1`, 另外, 那多出来的一行, 代表就是`s`是个空串, 对于一个空串来说, 它的子序列只有空串, 所以此时只要`t`不是空串, 那都找不到相同的个数.初始化为零
  ![image-20250411095859296](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411095859439.png)
  另外要考虑的一点是下标映射关系的改变, 对此我们可以通过在原先的字符的前面加一个`' '`, 来修正映射关系, 从而继续直接映射, 不过你也可以不加空字符, 直接使用间接映射, 就是把行列都减一
- **填表顺序**
  对于一个格子来说, 需要上面临近的格子和左上角的相邻格子, 所以我们要从上往下,   从左往右(从右往左倒也行, 但不太自然)
- **返回值**
  题目要我们从整个`s`的子序列中找`t`, 所以对应的是最右下角的格子.

## 代码编写

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        const int mod = 1e9 + 7;
        int m = s.size(), n = t.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for(int i = 0; i <= m; ++i) dp[i][0] = 1;
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                if(s[i-1] == t[j-1]) dp[i][j] += dp[i-1][j-1] % mod;
                dp[i][j] += dp[i-1][j] % mod;
            }
        }
        return dp[m][n];
```

 # 完