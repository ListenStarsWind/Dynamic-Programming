# [正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

![image-20250411201231072](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411201231158.png)

## 题目解析

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。

**示例一**


>输入：s = "aa", p = "a"
>输出：false
>解释："a" 无法匹配 "aa" 整个字符串。

`p`中只有一个普通字符`a`, 只能把`s`中的某一个`a`匹配掉, 剩下的一个无法匹配, 返回`false`

**示例二**


>输入：s = "aa", p = "a\*"
>输出：true
>解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

`*`不能单独存在, 他会与前面的字符, 这里就是`a`构成一个整体, 从而表示任意个数(包括零在内)的任意字符串, 因而`a*`可以表示`""`(0个`a`), 可以表示`"a"`(1个`a`), 可以表示`"aa"`(2个`a`).......    在这里, 他就可以匹配掉`s`的`aa`, 进而返回`true`

**示例三**


>输入：s = "ab", p = ".\*"
>输出：true
>解释：".\*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

**示例四**


>输入：s = "aab", p = "d\*a\*."
>输出：true
>解释："d*"可以与空字符串作匹配, "a\*"可以把"aa"匹配掉, "."可以与"b"匹配

最后我们再注意一下提示:  `*`绝对合法, 不可能出现`**`情况, 也不可能`*`前面没字符

## 算法原理

- **状态表示**
  还是老样子, 我们从`s, p`中取出两个子串, 例如, 可以将`s`的`[0,i]`区间拿出来做一个子串, 再把`p`的`[0,j]`区间拿出来做一个子串, 然后看这两个子串能不能完全匹配, 能, 那就定义`dp[i][j]`为`true`, 否则, 就将其定义为`false`
  ![image-20250411122238889](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411122238957.png)

- **状态转移**
  我们根据任何一个位置, 分情况讨论.                   有两个最后位置, 分别是`s[i]`和`p[j]`, 该选择哪一个呢? 我们选择`p[j]`, 因为它可能含有特殊字符, 为此就需要进行分类讨论. 

  首先是第一种情况, `p[j]`是正常字符, 也就是26小写字母中的一员, 我们要两个子串完全匹配, 那最起码最后一个位置要相同吧? 即`s[i] == p[j]`, 如果末尾字符确实相同, 那么末尾的两个字符就已经被我们匹配掉了, 剩下的就是`[0,i-1]`和`[0,j-1]`这两个区间, 只要它们也能完全匹配, 那吗`[0,i]`和`[0,j]`就是可以完全匹配的. 这样就有`dp[i][j] = s[i] == p[j] && dp[i-1][j-1]`

  第二种情况, 则是`p[j]`是`.`, `.`可以适配任意字符, 所以此时`i,j`这两个位置肯定能匹配掉, 剩下的还是`[0,i-1]`和`[0,j-1]`这两个区间, 这样的话, `dp[i][j] = dp[i-1][j-1]`

  第三种情况, 则是`p[j]`是`*`, 我们知道, `*`不能单独存在, 它必须把前面的字符, 也就是`p[j-1]`拉过来, 才能构成有意义的实体. 此时这个`p[j-1]`也有两种情况, 一是它就是普通的英文字母, 二是, 它为`.`
  对于`p[j-1]`为`.`时, 又可以分为多种选择, 由于`*`可以表示任意个数的前面字符, 所以首先我们可以将个数视为0, 这样的话, 它们就匹配掉了空串, 这样的话, 就剩下了`[0,i]`和`[0,j-2]`, 只要这两个区间能匹配上, 那`[0,i]`和`[0,j]`就可以匹配成功, 此时有`dp[i][j] = dp[i][j-2]`

  接着, 我们可以把个数加到1, 这样在匹配进行完后, 剩下的部分就是`[0,i-1]`和`[0,j-2]`, 同理`dp[i][j] = dp[i-1][j-2]`
  然后, 我们可以把个数加到2, 这样在匹配进行完后, 剩下的部分就是`[0,i-2]`和`[0,j-2]`, 同理`dp[i][j] = dp[i-2][j-2]`
  ..........................
  它们是对于`p[j-1]`为`*`号时的不同解决方案, 只要有一个解决方案成立, 那么`dp[i][j]`就为`true`

  但现在还有一个问题, 那就是这个循环是建立在动规前提下的, 动规的时间复杂度是$O(N^2)$, 这次循环的时间复杂度则是$O(N)$, 它俩一乘, 就有了$O(N^3)$级别的复杂度, 这复杂度太高了, 我们需要想办法将`p[j-1]`为`*`号时的验证过程化简为常数级别复杂度.

  为此, 有两种选择, 第一种选择是, 我们以数学的方式把递推公式求出来

  现在我们有`dp[i][j] = dp[i][j-2] || dp[i-1][j-2] || dp[i-2][j-2] || dp[i-3][j-2]........`, 这类似于数列中某一项的求解, 我们可以将`i`替换为`i-1`, 来求出与之对应的前一项

  `dp[i-1][j] = dp[i-1][j-2] || dp[i-2][j-2] || dp[i-3][j-2]..........`        两式合并, 就有了`dp[i][j] = dp[i][j-2] || dp[i-1][j]`, 

  第二种选择, 实际上就是为上面数学方式推导出的公式进行实际意义上的解释

  我们可以认为`*`号有两种行为模式

  第一种行为模式, `*`连同前面的字符把`i`位置匹配掉, 然后自己保留, 此时就剩下`[0,i-1]`和`[0,j]`这两个区间, 只要它们能完全匹配, 那`[0,i]`, `[0,j]`位置就是完全匹配的, 即`dp[i][j] = dp[i-1][j]`, 如何理解这种行为呢? 先前我们是分析先匹配掉一个字符, 在匹配掉两个字符, 三个字符分类讨论的, 但它们其实可以分散到各个子过程中, 比如对于`dp[i-1][j]`来说, 其`q[j]`仍旧是`*`, 所以可以继续匹配, 匹配掉一个字符, 这样剩下的就是`[0,i-2]`和`[0,j]`, `[0,i-2]`对于`[0,i]`来说, 不就是匹配掉两个字符吗? 这样就有`dp[i-1][j] = dp[i-2][j]`, 而对于`dp[i-2][j]`来说, 它的`p[j]`还是`*`, `p[j-1]`还是`.`, 所以可以继续匹配掉一个字符, 这样剩下的就是`[0,i-3]`, `[0,j]`, `[0,i-3]`对于`[0,i]`来说, 其实就是匹配掉三个字符的情况.........
  所以说, 我们这里并没有舍弃掉对于匹配掉两个, 三个, 四个字符的情况, 而是把这些情况分散到了之前的状态中讨论

  第二种行为模式是, `.*`和空气, 也就是空字符串斗智斗勇, 此时`.*`将被空字符匹配掉, 这样剩下的就是`[0,i]`和`[0,j-2]`, 即`dp[i][j-2]`

  这两种行为模式是并列关系, 所以只要其中任意一个能走通, 整体就能走通, 故而`dp[i][j] = dp[i][j-2] || dp[i-1][j]`

  我们上面分析了`*`号前面是`.`的情况, 接下来要分析`*`号前面是普通字符的情况.

  根据`*`的行为模式, 我们可以认为, 与普通字符结合成一个整体的`*`有两种行为

  第一种行为, `*`带着它前面的字符和空字符串同归于尽, 这样, 就剩下了`[0,i]`和`[0,j-2]`这两个区间, 就有`dp[i][j] = dp[i][j-2]`

  第二种行为, `*`带着它前面的字符和`s[i]`进行匹配, 但由于这里是普通字符, 所以不一定匹配成功, 这种行为必须在匹配成功的情况下再进行, `s[i] == p[j-1]?`  在匹配成功之后, 剩下的就是`[0,i-1]`和`[0,j]`, 即`dp[i-1][j]`, 由于它俩是递进关系, 所以`dp[i][j] = s[i] == p[j-1] && dp[i-1][j]`

  至此, 我们就分析完成了, 下面我们再把状态表示精炼一下, 

  我们可以把前面中情况(末尾普通字符或者`.`)归纳成一种, 它们都是尝试匹配掉`s[i]`, 然后再看剩下的区间, 即`dp[i][j] = (s[i] == p[j] || p[j] == '.') && dp[i-1][j-1]`

  对于以`*`为结尾的情况, 我们发现, 无论是前面是普通字符或者前面是`.`, 都有和空字符同归于尽的情况`dp[i][j] = dp[i][j-2]`

  剩下的情况, 就是试图把`s[i]`匹配掉, 然后把其他可能交由之前的状态来判断, 为此, 我们首先要能匹配 `s[i] == p[j-1] || p[j-1] == '.'`, 之后传递给之前的状态, `dp[i-1][j]`, 他们是递进关系, `dp[i][j] = (s[i] == p[j-1] || p[j-1] == '.') && dp[i-1][j]`

- **初始化**
  尽管在状态表示中有`j-2`的情况, 但对此我们不必担心, 因为题目说`*`前面一定有字符, 所以我们只需要多建一行, 一列虚拟位置即可.   我们可以引入空字符串为虚拟位置赋予实际意义, 之后要注意下标映射关系和虚拟位置初始化

  ![image-20250411131655583](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250411131655640.png)

  对于第一列, 代表`p`取出了一个空串, 对于空串来说, 除非`s`取出的也是空串, 否则都无法匹配, 这样, 第一列除了`dp[0][0]`, 其他都是`false`

  对于第一行来说, 代表`s`取出了一个空串, 那谁能匹配空串呢? 很明显是`*`, 因为他也可以让自己前面字符的个数变为零, 这样就能匹配空串了, 空串被匹配掉之后, 仍旧是空串, 然后`p`却失去了最后两个字符, 此时就要看`[0,j-2]`区间是否能匹配空串了. 它俩是递进关系

- **填表顺序**
  根据状态表示, 我们了解到, 对于一个格子来说, 可能需要左边和上边的格子, 因而顺序为从左往右, 从上往下

- **返回值**

  题目问我们这两个串能不能完全匹配, 此时相当于`s,p`把自身取出来, 看它们是否可以完全匹配

## 代码编写

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        vector<vector<bool>> dp(m+1, vector<bool>(n+1));
        dp[0][0] = true;
        for(int j = 1; j <= n; ++j)
            dp[0][j] = p[j-1] == '*' && dp[0][j-2];
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                if(p[j-1] == '*') dp[i][j] = dp[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j];
                else dp[i][j] = (s[i-1] == p[j-1] || p[j-1] == '.') && dp[i-1][j-1];

                // if(p[j-1] == '.' || p[j-1] == s[i-1]) dp[i][j] = dp[i-1][j-1];
                // else if(p[j-1] == '*') dp[i][j] = dp[i][j-2] || dp[i-1][j] && (p[j-2] == s[i-1] || p[j-2] == '.'); 
            }
        }
        return dp[m][n];
    }
};
```

# 完
