# [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

![image-20250410171739997](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410171740108.png)

## 题目解析

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。空字符串是任何字符串的子序列, 所以如果找不到有内容的公共子序列, 那就返回空串的长度零.

**示例一**

>```
>输入：text1 = "abcde", text2 = "ace" 
>输出：3  
>解释：最长公共子序列是 "ace" ，它的长度为 3 。
>```

**示例二**

>```
>输入：text1 = "abc", text2 = "abc"
>输出：3
>解释：最长公共子序列是 "abc" ，它的长度为 3 。
>```

**示例三**

>```
>输入：text1 = "abc", text2 = "def"
>输出：0
>解释：两个字符串没有公共子序列，返回 0 。
>```

## 算法原理

- **状态表示**
  想要找到最长的公共子序列, 首先要能从两个字符串中找出子序列, 为此, 我们可以将第一个字符串`s_1`的`[0,i]`区间, 和第二个字符`s_2`的`[0,j]`区间作为研究对象, 从他们中找出子序列, 再从中找出最长的公共子序列, 为此, 我们定义`dp[i][j]`为基于如上两个区间的最长公共子序列的长度
- **状态转移**
  状态转移还是老样子: 基于对原始数据的分析, 推导状态转移的过程. 我们可以根据两个字符串当前研究区域的最后一个元素, 也就是`s_1[i]`和`s_2[j]`进行分析.         当这两个字符相同时, 因为我们要的是最长公共子序列, 那既然最后两个字符相同, 那完全可以把它们带上, 多多益善, 此时形成的公共子序列, 不就相当于是以`s_1`的`[0,i-1]`和`s_2`的`[0,j-1]`区间 中的最长公共子序列再加上最后那个元素吗? 此时得到的最长公共子序列长度就是`dp[i-1][j-1]+1`, 
  当这两个子序列不相同时, 说明最长公共子序列的末尾一定不会是它俩, 虽然不能同时, 但我们可以尝试一下错峰, 有三种方案, 第一种方案, 在`s_1`的`[0,i-1]`和`s_2`的`[0,j]`这两个区间里寻找最长公共子序列, 第二种方案, 在`s_1`的`[0,i]`和`s_2`的`[0,j-1]`这两个区间里寻找最长的公共子序列, 至于第三种方案, 则是一种最悲观的方案, 那就是公共子序列它既不以`s_1[i]`为结尾, 也不以`s_2[j]` 为结尾, 那此时, 我们只能从`s_1`的`[0,i-1]`和`s_2`的`[0,j-1]`, 这两个区间中寻找最长公共子序列, 由于我们这里要求的是最长, 所以其实可以无脑取三个方案中的最大值, 但是, 其实这三个方案中其实是含有包含与被包含的关系的, 我们用图像的形式, 会更清楚.
  ![image-20250410180016668](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410180016742.png)
  ![image-20250410180113376](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410180113425.png)
  ![image-20250410180140928](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410180140984.png)
  我们可以很清楚地看出, 对于方案一和方案三来说, 它们对于`s_1`的研究区域相同, 而在`s_2`里, 方案一则比方案三多了一个格子, 所以方案一其实是包含着第三种方案的, 同理, 方案二也是包含方案三的, 所以我们填表的时候其实可以直接忽略掉方案三, 只对方案一和方案二取最大值
- **初始化**
  根据状态转移, 我们可以知道, 当分析`[i][j]`位置时, 我们可能会遇到`[i-1][j-1]`的情况, 从而导致越界. 我们可以直接初始化, 可能会产生越界的第一行和第一列, 此时两个字符串中的一个区间的长度就会变为1, 只要另一个区间有对应的字符, 那便初始化为1, 如果没有那就是零, 但这样太麻烦了, 所以我们可以建立虚拟位置, 我们多建一行一列, 行和列的下标都从`1`开始, 这样就不会越界了, 此时就需要干两件事, 第一件事是对虚拟位置进行初始化, 对于虚拟位置来说, 就相当于一个空字符串和另一个字符串取最长公共子序列, 显而易见, 此时它俩得出的最长公共子序列不就是空串吗? 空串长度不就是0吗? 所以我们直接对虚拟位置的值初始化为零就行了, 另外要注意的是, 要注意一下下标映射关系, 由于`dp`表新加了一行一列, 所以下标的映射关系就会被改变, 简要来说, 就是`k`下标实际对应字符串的`k-1`下标, 不过我们也可以对原来的两个字符串进行修正, 在它们之前都加一个`' '`字符, 这样就又能建立直接映射关系了
  ![image-20250410181909539](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250410181909579.png)
- **填表顺序**
  易得, 是从左往右, 从上往下
- **返回值**
  题目要的是两个字符串的最长公共子序列, 此时的区间为`s_1[0,i]`和`s_2[0,j]`, 就是`dp`右下角的那个格子

## 代码编写

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        string s1 = " " + text1;
        string s2 = " " + text2;
        int m = s1.size(), n = s2.size();
        vector<vector<int>> dp(m, vector<int>(n));
        for(int i = 1; i < m; ++i)
        {
            for(int j = 1; j < n; ++j)
            {
                if(s1[i] == s2[j])
                dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
            }
        }
        return dp[m-1][n-1];
    }
};
```

# 完