# [两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)

![image-20250412113141995](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412113142068.png)

## 题目解析

给定两个字符串`s1` 和 `s2`，返回 *使两个字符串相等所需删除字符的 **ASCII** 值的最小和* 。

**示例一**


>输入: s1 = "sea", s2 = "eat"
>输出: 231
>解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
>在 "eat" 中删除 "t" 并将 116 加入总和。
>结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。

**示例二**


>输入: s1 = "delete", s2 = "leet"
>输出: 403
>解释: 在 "delete" 中删除 "dee" 字符串变成 "let"，
>将 100[d]+101[e]+101[e] 加入总和。在 "leet" 中删除 "e" 将 101[e] 加入总和。
>结束时，两个字符串都等于 "let"，结果即为 100+101+101+101 = 403 。
>如果改为将两个字符串转换为 "lee" 或 "eet"，我们会得到 433 或 417 的结果，比答案更大。

如果我们以`eet`为目标, 对于`delete`来说, 就需要删除`dle`, 对于`leet`来说, 就需要删除`l`, 
以`let`为目标, 对于`dlelte`来说, 就需要删除`dee`, 对于`leet`来说, 就需要删除`e`
以`lee`为目标, 对于`delete`来说, 就需要删除`det`, 对于`leet`来说, 就需要删除`t`

我们看到, 题目最后要把这两个字符串变成相同的, 但实际上, 我们也可以认为, 题目要我们找的是两个字符串的公共子序列, 并且, 题目还有一个定语"删除和最小", 那对于留下来的部分来说, 不就是"留下和最大"吗, 所以我们可以把整道题转化为求两个字符串里面所有的公共子序列里面, 最大的ASCII码和

## 算法原理

- **状态表示**

  我们定义`dp[i][j]`表示在`s1`的`[0,i]`区间和`s2`的`[0,j]`区间中所有子序列中, 公共子序列中ASCII码的最大和.

  ![image-20250412120209004](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412120209048.png)

- **状态转移**
  对于这两个子序列来说, 依据最后一个位置, 可以分成四种情况, 它们分别是, `s1`取出的子序列包含`s1[i]`, `s2`取出的子序列包含`s2[j]`           `s1`取出的子序列包含`s1[i]`, 但`s2`取出的子序列中没有`s2[j]`,               `s1`取出的子序列没有`s1[i]`, `s2`取出的子序列有`s2[j]`,                 `s1`取出的子序列没有`s1[i]`, `s2`取出的子序列没有`s2[j]`                 接下来, 我们只需要看看这四种情况里哪一个ASCII码最大就行

  第一种情况, 是`s1`里面有`s1[i]`, `s2`里面有`s2[j]`, 对于这种情况, 因为我们要的是公共子序列, 所以要有`s1[i] == s2[j]`, 如果不满足, 这种情况就无法形成公共子序列, 我们也不必统计它的ASCII码和, 如果满足, 那么剩下的事就是在`[0,i-1]`和`[0,j-1]`区间里面先找一个公共最大ASCII和再加上后面相同的元素,. 即`dp[i-1][j-1] + s1[i]`

  第二种情况是, 有`s1[i]`, 但没有`s2[j]`, 对于这种情况, 我们可以将其视为剩下`[0,i]`和`[0,j-1]`, 即`dp[i][j-1]`, 但需要注意的是, 它们并不等效, 不等效的原因是我们的四种情况划分其实并不是完全的独立事件, 而是存在重叠情况的, 比如说, 对于`dp[i][j-1]`来说, 我这`s2[j]`确实不会有, 但对于`s1[i]`来说, 也是可以分为有和没有两种情况的,如果`s1[i]`没有的话, 它其实就变成了第四种情况, 也就是说`dp[i][j-1]`不仅包含了第二种情况, 也包含了第四种情况 所以这里可以看出, `dp[i][j-1]`的探讨对象范围是超过第二种情况的, 但这里会不会有影响呢? 其实不会, 因为我们要的是最大值, 所以不需要严格的等效

  第三种情况是, 有`s2[j]`, 但没有`s1[i]`, 和第二种情况相同, 它可以认为是`dp[i-1][j]`, 但并不等效

  第四种情况是, `s1[i], s2[j]`都没有, 对于这种情况, `dp[i-1][j-1]`不会造成返回的扩大

  由于第二种情况和第三种情况的讨论会包含第四种情况, 我们要的又是最大值, 所以将第四种情况整体舍弃也是可行的.

- **初始化**

  对于某个格子来说, 它可能会用到上边, 左边, 左上角的格子, 所以会对第一行和第一列造成越界情况, 因此我们需要引入虚拟位置, 我们可以使用空字符串为虚拟位置赋予实际意义, 对于新加的第一行和第一列来说, 由于其中一个字符串是空的, 所以公共子序列是有空串这一种情况, 空串的ASCII码和就是零

- **填表顺序**

  从左往右, 从上往下

- **返回值**

  找出最大和后, 把两个字符串的总和求出来, 减去两份最大和, 就得到了最小删除和

## 代码编写

```cpp
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                if(s1[i-1] == s2[j-1])
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + s1[i-1]);
            }
        }
        int result = 0;
        for(int i = 0; i < m; ++i) result += s1[i];
        for(int j = 0; j < n; ++j) result += s2[j];
        result -= dp[m][n] * 2;
        return result;
    }
};
```

# 完
