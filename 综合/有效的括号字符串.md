# [有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/)

![image-20250606135711549](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250606135711639.png)

## 代码编写

```cpp
/*
    解法一, 动态规划, 当做是普通的, 不含'*'的括号匹配
    首先确定边界/初始化条件, 当子串只有一个字符时, 只有
    该字符是'*', 才能匹配成功

    当子串有两个字符时, 以下的种种情况, 可以使得其也匹配
    成功, 
    (                 )
    (                 *
    *                 )
    *                 *

    当子串中大于两个字符时, 对于字符串的匹配, 存在两种方案
    一种是, 这个字符串末尾的两个字符就能匹配, 并且它们中间
    的子串也能匹配, 此时整个子串就是匹配的

    另外一种方案是, 在子串的基础上再进行分化, 我们在子串
    中寻找这样的一个位置, 它可以把子串分成两个子串, 并且
    这两个子串都是可以匹配成功的
*/
class Solution {
public:
    bool checkValidString(string s) {
        char x[4] = {'(', '(', '*', '*'};
        char y[4] = {')', '*', ')', '*'};

        int n = s.size();
        bool dp[100][100] = {0};
        if(s[n-1] == '*') dp[n-1][n-1] = 1;
        for(int i = n - 2; i >= 0; --i)
        {
            if(s[i] == '*') dp[i][i] = 1;
            for(int j = i + 1; j < n; ++j)
            {
                for(int k = 0; k < 4; ++k)
                {
                    if(s[i] == x[k] && s[j] == y[k])
                    {
                        if(i+1 > j-1 || dp[i+1][j-1])
                        {
                            dp[i][j] = 1;
                            break;
                        }
                    }
                }

                for(int k = i; k < j; ++k)
                {
                    if(dp[i][k] && dp[k+1][j])
                    {
                        dp[i][j] = 1;
                        break;
                    }
                }
            }
        }

        return dp[0][n-1];
    }
};


/*
    解法二: 双栈, 两个栈分别维护左括号的星号
    遇到左括号和星号, 放到对应的栈中, 备用
    遇到右括号, 优先和左括号栈配对, 无法配对
    时, 利用星号的通配符性质, 将其转化成左括号
    进行配对, 当星号也没有时, 无法进行配对

    字符串遍历完后, 利用星号可以成为右括号的
    性质, 对左括号栈中的元素一一配对, 最后
    左括号栈已经为空, 就可以把剩下的星号当做空

    值得注意的是, 在遍历完整个字符串, 使用剩余
    的星号对左括号进行删除时, 必须确保, 星号位于
    左括号的右边, 为此, 我们在栈中存储字符的下边
    以在最后, 判断它们的先后顺序
*/

class Solution {
public:
    bool checkValidString(string s) {
        if(s.size() == 1)
        {
            if(s[0] == '*')
                return true;
            else
                return false;
        }

        stack<int> stk1;
        stack<int> stk2;

        int n = s.size();
        for(int i = 0; i < n; ++i)
        {
            if(s[i] == '(')
                stk1.push(i);
            else if(s[i] == '*')
                stk2.push(i);
            else
            {
                if(!stk1.empty())
                    stk1.pop();
                else
                {
                    if(!stk2.empty())
                        stk2.pop();
                    else
                        return false;
                }
            }
        }

        while(!stk1.empty() && !stk2.empty())
        {
            int a = stk1.top();
            int b = stk2.top();
            stk1.pop();
            stk2.pop();

            if(a > b) return false;
        }

        return stk1.empty();
    }
};

/*
    解法三: 上下界
    在解法二的双栈解法中, 如果不是为了最后遍历完字符串, 对剩下的
    左括号进行配对, 我们甚至可以根本不使用栈, 毕竟这些栈中所存储的
    字符都是确定的, 使用栈只是最后为了进行先后顺序的验证, 能不能把
    最后的这个验证环节也融入到字符串遍历过程中呢? 这就是第三种解法
    上下界

    星号为左括号的数量带来了不确定性, 它可以变成左括号, 使得左括号的
    数目加一, 亦可以变成右括号, 使得左括号的数目减一, 当然, 前提是还
    有左括号, 亦或者可以根本当做空不进行计算, 这样的话, 我们就可以
    维护一个表示当前左括号数目的上下界, 上界表示当前情况最大的左括号
    数目, 下界表示当前情况最小的左括号数目

    对于左括号和右括号来说, 由于他们是确定的, 所以直接对两个界进行相应
    的加加减减即可, 而对于星号来说, 具有不确定性, 所以此时上界便加一,
    下界便减一, 值得注意的是, 上下界表示的都是个数, 它们都不能为负数,
    对于下界来说, 它为负意味着当前右括号过多, 尽管这可能是我们把星号
    都变成右括号造成的, 所以当下界已经为零时, 星号的不确定性会被减弱
    因为它无法选择右括号, 所以我们不会对已经为零的下界再减减, 对于上
    界来说, 它为负, 意味着, 即使把所有星号全部转化成左括号, 也无法填补
    缺口, 它会把星号的不确定直接变成确定的, 既然信号全部转换成左括号
    仍旧不够, 那么部分转化, 甚至有些转化成右括号, 自然也是不行的, 所以
    此时信号的概率塌缩了, 它已经不是波函数了. 下界的情况是概率值减弱, 但
    并没有塌缩, 因为别的方案仍旧是存在可能成功的.

    对于右括号过多的情况, 在遍历字符串的时候, 程序会自动退出, 接下来我们
    只需要确保不剩下多余的左括号.

    上下界所维护的区间表示着对星号进行不同转换最后能剩下的左括号数目,
    只要最后该区间内出现零, 就表示存在着消除所有左括号的方案, 又因为
    下界是最小的可能数目, 所以只需要它小于等于零即可, 并且, 之前我们
    对于下界已经为零, 不再执行减操作, 这意味着下界不会为负, 所以最后
    判断下界是否等于零即可.
*/

class Solution {
public:
    bool checkValidString(string s) {
        int low = 0;
        int hig = 0;
        for (auto c : s) 
        {
            if (c == '(') 
            {
                ++low;
                ++hig;
            } 
            else if (c == ')') 
            {
                low = max(0, --low);
                if (hig == 0)
                    return false;
                --hig;
            } 
            else 
            {
                low = max(0, --low);
                ++hig;
            }
        }

        return low == 0;
    }
};
```

