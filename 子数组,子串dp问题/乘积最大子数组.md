# [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray)

![image-20250405122036511](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405122036563.png)

## 题目解析

给你一个整数数组, 请在里面找出一个子数组, 并使得该子数组中的元素乘积最大. 你不必担心整数溢出问题

**示例一**

>```
>输入: nums = [-2,-3,2,4]
>输出: 48
>解释: 子数组 [-2, -3, 2, 4] 有最大乘积 48
>```

**示例二**

>```
>输入: nums = [-2,0,-1]
>输出: 0
>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
>```

## 算法原理

- **状态表示**

  老样子, 我们可以依据经验加题目要求, 定义`dp[i]`为以`i`位置为结尾子数组的最大积, 但仅定义一维其实还不够, 比如在示例一中, 我们可以看到, `nums[i]`可能有正或者负这两种可能, 这两种情况有不同的寻找最大积策略, 比如, 对于示例一`1`号下标的`-3`来说, 它应该去前面找最小积, 找到`-2`, 相乘得`6`,   而对于`2`号下标的`2`来说, 它应该去找前面 积最大的, 而不是积最小的, 找到了6, 所以相乘结果是12.

  因此, 我们还要加一维, 我们定义`f[i]`为以`i`为结尾子数组中的最大积, 而`g[i]`为以`i`为结尾子数组最小积.

- **状态转移**

  我们一个一个来看, 先看`f[i]`, `f[i]`表示以`i`为结尾子数组最大积, 对此, 有两种情况, 一是, 这个子数组的长度为一, 或者说这个子数组就是它本身, 二是, 这个子数组的长度不为一, 也就是说它前面还要乘上一个数, 我们要取其中结果更大的那个.

  ![image-20250405104032269](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405104032323.png)

  需要注意的是, 如果长度不为一, 也就是说前面还要乘上一个数, 那这个乘数需要依据`nums[i]`的具体情况进行分析, 如果`nums[i]`为正数, 那么就应该从前面找一个最大积, 也就是`f[i-1]`, 如果`nums[1]`为负数, 那就应该从前面找一个最小积, 也就是`g[i-1]`.

  对于`g[i]`来说, 亦是同理, 如果子数组长度就为一, 那就是它本身, 如果长度超过一, 那就需要进行讨论, 当`nums[i]`为正数时, 因为要求的是最小积, 所以应该去前面找一个最小的积,也就是`g[i-1]` 而当`nums[i]`为负数是, 那就应该去前面找一个最大积, 也就是`f[i-1]`

  为此, 就有状态转移方程, (以`x`代称`nums[i]`) 

  `f[i] = x < 0 ? min(1, g[i-1]) * x : max(1, f[i-1]) * nums[i];`

  `g[i] = x < 0 ? max(1, f[i-1]) * x : min(1, g[i-1]) * x;`

- **初始化**

  这里我们采用新建虚拟位置方案, 在前面建立一个虚拟位置, 为此, 需要注意下标映射关系, 和虚拟位置初始值, 以第一个有效位置为结尾的子数组不就它本身吗? 所以虚拟位置设置为一就行了, 一乘任何数不都是它自身吗

- **填表顺序**

  易知, 从左往右, 两表同填

- **返回值**

  题目要的是最大积, 所以返回`f`里的最大值就行了

## 代码编写

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size(), result = INT_MIN;
        vector<int> f(n+1, 1); auto g = f;
        for(int i = 1; i <= n; ++i)
        {
            int x = nums[i-1];	
            f[i] = x < 0 ? min(1, g[i-1]) * x : max(1, f[i-1]) * x;
            g[i] = x < 0 ? max(1, f[i-1]) * x : min(1, g[i-1]) * x;
            result = max(result, f[i]);
        }
        return result;
    }
};

/*
   全新的新路

   题目要求我们从所给数组中, 找出一个子数组, 使得其中元素的积最大化, 特别的, 观察示例二可以发现, 当数组中的元素小于2时,
   数组中元素的乘积结果就是这单个元素本身, 而对于数组长度大于1的情况, 若要求出它的乘积, 可以将该数组再进行拆分, 拆分成
   长度更小到的两个子数组, 这两个子数组各有自身元素的乘积, 这两个乘积相乘就得到了大数组的元素积.

   这样的话, 对于初始数组中的每个元素, 我们都有两种大的应对策略, 一是让它自成为一个子数组, 此时它的乘积, 就是它本身
   我们将这种子数组的元素乘积结果称之为a, 二是, 让这个a和前面的子数组相乘, 这样就可以得到一个新的乘积. 然后, 对这两
   种策略进行比较, 选择我们需要的结果.

   对于策略一来说, 他的乘积是确定的, 所以接下来的任务就是, 在策略二中, 我们具体该选择前面的什么样的子数组.

   这和a本身的性质有关, 若a本身为负数, 我们都知道, 负负得正, 如果前面的子数组能乘出来一个负数的乘积, 那么这两个负数
   一相乘, 结果就会变大, 而且, 此时, 前面的子数组的这个负数乘积的绝对值越大越好, 这样得到的结果也就越大, 而对于负数
   而言, 绝对值越大, 它就越小, 这意味着, 在整个过程中, 我们不仅仅需要求乘积最大的子数组, 还需要求乘积最小的子数组
   除了负数本身之外, 另外一个和负数相乘之后结果还能变大的, 那就是零了, 从负数变成非负数了, 显而易见是变大的, 那这个
   零该怎么办? 我们还要再多建一个维度吗? 先考虑能不能在前面找到负数乘积? 找不到再去看能不能找到零? 但如果真的要再建
   一个维度, 似乎太麻烦了. 我们可以看到, 它们之前是存在优先级的, 我先去前面的子数组里面找最小的乘积, 找不到再找零,
    而对于乘积最小的子数组, 它遵循相同的逻辑, 因为对于零来说, 它显而易见是比负数要大的, 所以前面的数组能找到负数必然
    会将这个负数作为最小的乘积, 但如果找不到负数, 他可能会将零或者正数作为最小的乘积. 所以我们只需要寻找最小乘积就可以了

    若a本身为正数, 如果还要从前面找子数组, 那么应该去找乘积最大的

    若本身为零, 因为必须要以它为结尾, 所以无论最小最大, 都是零, 此时无论是策略一还是策略二, 结果都是一样的, 所以我们省略策略二

    dp 规模, 考虑到原始数组的长度大小是1 <= nums.length <= 2 * 10000 那么我们可以创建
    10001(最前面的一表示虚拟位) * 2 ([0]表示最小, [1]表示最大)

    返回值, 寻找最大的[1], 

    虚拟位置的初始状态
    对于最前面的元素来说, 其实对应的就是空数组, 我们依据0次方等于1的这样的数学规律, 对于它们初始化为1
*/

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int dp[20001][2] = {0};
        dp[0][0] = dp[0][1] = 1;

        int ans = INT_MIN;
        int n = nums.size();
        for(int i = 1; i <= n; ++i)
        {
            dp[i][0] = dp[i][1] = nums[i-1];
            if(nums[i-1] > 0)
            {
                dp[i][0] = min(dp[i][0], dp[i][0] * dp[i-1][0]);
                dp[i][1] = max(dp[i][1], dp[i][1] * dp[i-1][1]);
            }
            else if(nums[i-1] < 0)
            {
                dp[i][0] = min(dp[i][0], dp[i][0] * dp[i-1][1]);
                dp[i][1] = max(dp[i][1], dp[i][1] * dp[i-1][0]);
            }
            ans= max(ans, dp[i][1]);
        }

        return ans;
    }
};
```

# 完