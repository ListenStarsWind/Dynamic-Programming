# [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray)

![image-20250405122036511](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405122036563.png)

## 题目解析

给你一个整数数组, 请在里面找出一个子数组, 并使得该子数组中的元素乘积最大. 你不必担心整数溢出问题

**示例一**

>```
>输入: nums = [-2,-3,2,4]
>输出: 48
>解释: 子数组 [-2, -3, 2, 4] 有最大乘积 48
>```

**示例二**

>```
>输入: nums = [-2,0,-1]
>输出: 0
>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
>```

## 算法原理

- **状态表示**

  老样子, 我们可以依据经验加题目要求, 定义`dp[i]`为以`i`位置为结尾子数组的最大积, 但仅定义一维其实还不够, 比如在示例一中, 我们可以看到, `nums[i]`可能有正或者负这两种可能, 这两种情况有不同的寻找最大积策略, 比如, 对于示例一`1`号下标的`-3`来说, 它应该去前面找最小积, 找到`-2`, 相乘得`6`,   而对于`2`号下标的`2`来说, 它应该去找前面 积最大的, 而不是积最小的, 找到了6, 所以相乘结果是12.

  因此, 我们还要加一维, 我们定义`f[i]`为以`i`为结尾子数组中的最大积, 而`g[i]`为以`i`为结尾子数组最小积.

- **状态转移**

  我们一个一个来看, 先看`f[i]`, `f[i]`表示以`i`为结尾子数组最大积, 对此, 有两种情况, 一是, 这个子数组的长度为一, 或者说这个子数组就是它本身, 二是, 这个子数组的长度不为一, 也就是说它前面还要乘上一个数, 我们要取其中结果更大的那个.

  ![image-20250405104032269](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405104032323.png)

  需要注意的是, 如果长度不为一, 也就是说前面还要乘上一个数, 那这个乘数需要依据`nums[i]`的具体情况进行分析, 如果`nums[i]`为正数, 那么就应该从前面找一个最大积, 也就是`f[i-1]`, 如果`nums[1]`为负数, 那就应该从前面找一个最小积, 也就是`g[i-1]`.

  对于`g[i]`来说, 亦是同理, 如果子数组长度就为一, 那就是它本身, 如果长度超过一, 那就需要进行讨论, 当`nums[i]`为正数时, 因为要求的是最小积, 所以应该去前面找一个最小的积,也就是`g[i-1]` 而当`nums[i]`为负数是, 那就应该去前面找一个最大积, 也就是`f[i-1]`

  为此, 就有状态转移方程, (以`x`代称`nums[i]`) 

  `f[i] = x < 0 ? min(1, g[i-1]) * x : max(1, f[i-1]) * nums[i];`

  `g[i] = x < 0 ? max(1, f[i-1]) * x : min(1, g[i-1]) * x;`

- **初始化**

  这里我们采用新建虚拟位置方案, 在前面建立一个虚拟位置, 为此, 需要注意下标映射关系, 和虚拟位置初始值, 以第一个有效位置为结尾的子数组不就它本身吗? 所以虚拟位置设置为一就行了, 一乘任何数不都是它自身吗

- **填表顺序**

  易知, 从左往右, 两表同填

- **返回值**

  题目要的是最大积, 所以返回`f`里的最大值就行了

## 代码编写

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size(), result = INT_MIN;
        vector<int> f(n+1, 1); auto g = f;
        for(int i = 1; i <= n; ++i)
        {
            int x = nums[i-1];	
            f[i] = x < 0 ? min(1, g[i-1]) * x : max(1, f[i-1]) * x;
            g[i] = x < 0 ? max(1, f[i-1]) * x : min(1, g[i-1]) * x;
            result = max(result, f[i]);
        }
        return result;
    }
};
```

# 完