# [环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string)

![image-20250406170501948](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250406170502020.png)

## 题目解析

定义字符串 `base` 为一个 `"abcdefghijklmnopqrstuvwxyz"` 无限环绕的字符串，所以 `base` 看起来是这样的：

- `"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...."`.

给你一个字符串 `s` ，请你统计并返回 `s` 中有多少 **不同** **非空子串** 也在 `base` 中出现。

**示例一**

>```
>输入：s = "a"
>输出：1
>解释：字符串 s 的子字符串 "a" 在 base 中出现。
>```

`base`中含有所有的小写英文字母, 所以对于单个字母来说, 一定是`base`的子串

**示例二**

>```
>输入：s = "cac"
>输出：2
>解释：字符串 s 有两个子字符串 ("a", "c") 在 base 中出现。
>```

`"cac"`可以分解出6个子串 : `["c", "ca", "cac", "a", "ac", "c"]`其中我们只需要考虑`["c", "a", "c"]`这三个, 需要的是不同的非空子串, 所以两个`"c"`只计入一个, 最后和是2.

**示例三**

>```
>输入：s = "zab"
>输出：6
>解释：字符串 s 有六个子字符串 ("z", "a", "b", "za", "ab", and "zab") 在 base 中出现。
>```

`base`是循环的, 因而`"za"`也被视为子串

## 算法原理

- **状态表示**
  找符合要求的子串首先要找到子串, 所以我们可以规定,`dp[i]`为以`i`为结尾的子串中满足要求的个数.

- **状态转移**
  以`i`为结尾的子串大致可以分为两类, 一是它可以自成一个子串, 由于单个字符一定是`base`的子串, 所以这种情况一定能给`i`贡献一个个数, 第二类是`i`位置和它前面的位置拼在一起构成子串, 如果以`i-1`位置为结尾已经有符合要求的子串了, 那这种情况就相当于在以`i-1`位置为结尾的符合要求的子串的后面再加个自身, 这样就能继承到`i-1`位置的个数, 但要注意的是, 继承是有条件的, 只有`i-1`和`i`位置本身是连续的, 拼接成的新字符串才是仍满足要求的, `i`才可以继承`i-1`的个数. 
  ![image-20250406173131210](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250406173131258.png)
   对于"连续"的判断, 有两种可能, 一是前面的ASCII码加上一等于我的ASCII码值   或者    前面是`"z"`, 后面是`"a"`
  最后把这两个渠道的贡献点数相加即可.

- **初始化**

  第一个字符一定会在`base`中出现, 所以它的位置应该初始化为一, 不过我们也可以把所有位置都初始化为`1`, 这相当给每个格给了一个保底点数, 所以接下来我们只需要看看`i-1`和`i`有没有连续那种情况了.

- **填表顺序**

  从左往右

- **返回值**

  我们不能直接返回`dp`中元素的和, 因为我们的`dp`中可能存在重复的子串, 就像示例二那样, 为此我们需要进行去重操作. 怎么去重呢? 其实很简单, 因为这些子串都是符合要求的, 所以如果其中两个子串有着相同的末尾值(末尾值相同, 又是符合要求(连续的), 所以倒数第二个字符也必然相同, 倒数第三也必然相同....), 它们就必然存在重复关系, 它们之间一定是包含和被包含的关系, 比如`"yzabc"`和`"abc"`, 很明显, `"yzabc"`包含`"abc"`, 所以我们只要`"yzabc"`的点数就行了, 如何判断谁包含谁呢? 很简单, `dp`值更大的那个包含`dp`值更小的那个.
  为此我们可以建立一个`26`大小的数组, 遍历一下`dp`表, 结合原始字符串`s`, 从而知晓末尾字符是谁, 然后杜宇末尾字符相同的子串, 我们保留最大的就行了. 最后我们返回这个数组中元素的和

 ## 代码编写

```cpp
class Solution {
public:
    int findSubstringInWraproundString(string s) {
        int n = s.size();
        vector<int> dp(n, 1);
        for(int i = 1; i < n; ++i)
        {
            if((s[i-1] + 1 == s[i]) || (s[i-1] == 'z' && s[i] == 'a'))
                dp[i] += dp[i-1];
        }

        int temp[26] = {0};
        for(int i = 0; i < n; ++i)
        {
            int idx = s[i] - 'a';
            temp[idx] = max(temp[idx], dp[i]);
        }
        int result = 0;
        for(int i = 0; i < 26; ++i)
        {
            result += temp[i];
        }
        return result;
    }
};
```

# 完