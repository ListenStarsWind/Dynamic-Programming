# [环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray)

![image-20250405095938129](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405095938230.png)

## 题目解析

给定一个长度为 `n` 的**环形整数数组** `nums` ，返回 *`nums` 的非空 **子数组** 的最大可能和* 。

第二段告诉你环形数组的寻址方案, 模`n`是为了防止越界, 比如说大小为四的数组, 4下标对应的就是`4 % 4 = 0`, 为什么前一个元素里面还要加一个`n`, 这是因为C/C++的负数取模和数学上的负数取模不一样, 数学上的`-1 % 4 = 3`, C/C++是`-1 % 4 = -1`, 所以要进行修正, 需要加上那个`n`

第三段话的意思是这个环形数组的子数组最多只能取一圈, 也就是数组中的所有元素, 你不能取完一圈又开始取.

第二三段其实对我们的算法原理并没有帮助, 所以我们直接忽略也行.

对于一个环形数组来说, 有如下的几种子数组划分方案(并没有全部画出)

![image-20250405101702885](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405101702923.png)

**示例一**

>```
>输入：nums = [1,-2,3,-2]
>输出：3
>解释：从子数组 [3] 得到最大和 3
>```

**示例二**

>```
>输入：nums = [5,-3,5]
>输出：10
>解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
>```

**示例三**

>```
>输入：nums = [3,-2,2,-3]
>输出：3
>解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
>```

## 预处理

本题直接使用动态规划不太好解, 为此, 我们可以采取类似于打家劫舍二的策略, 将环形序列解析为普通的非环形队列. 

我们的最后答案大致分为两类. 一种是不成环的, 一种是成环的.

![image-20250405102605106](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405102605154.png)

对于这种不成环的, 我们可以直接使用上题中的求非成环数组的最大和处理, 最终得到一个值

![image-20250405102817453](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405102817517.png)

对于这种成环的, 由于它是子数组的最大和, 而整个数组的和又是固定的, 阴影区域最大, 意味着空白区域最小. 所以对于这种情况, 我们不直接找最大的, 而是找最小子数组和. 然后再用数组的和减去子数组和, 就能得到阴影部分的和.

最后我们把这两种情况比较一下, 选取其中较大的那一个就行了.

## 算法原理

- **状态表示**

  还是依据经验和题目要求, 我们定义`f[i]`为以`i`位置为结尾的子数组中的最大和, `g[i]`为以`i`位置为结尾的子数组中的最小和.

- **状态转移**

  不管是`f[i]`还是`g[i]`, 是找最大和还是找最小和, 其以`i`为结尾的子数组都可以分为两种情况, 一是它本身自成一个子数组, 二是它本身加上它前面的最大/小和子数组, 构成了一个子数组

  ![image-20250405104032269](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405104032323.png)

  那前面那部分, 不就是以`i-1`为结尾的子数组中的最大或者最小和吗? 这不就是`f[i-1]`和`g[i-1]`

  于是有`f[i] = max(nums[i], f[i-1]+nums[i])`,    `g[i] = min(nums[i], g[i-1]+nums[i])`

- **初始化**

  为了让第一个有效位置不越界, 我们可以在第一个有效位置的前面加一个虚拟位置, 接下来就是要注意下标映射关系和虚拟位置初始化了, 我们可以想一下, 如果没有虚拟位置, 那以第一个有效位置为结尾的子数组和不就是它本身吗? 所以我们要让`max or min`都选择前面的那一个, 所以我们可以将虚拟位置初始化为零, 这样前面和后面不就相当于相等吗? 这样最后得到的结果就是前面的. 

- **填表顺序**

  从左往右, 两表同填

- **返回值**

  我们的预处理环节其实有一个小问题, 比如对于`[-2, -3, -1]`这种全为负数的数组, 和最小的子数组就是整个数组, 而和最大的子数组是`-1`, 此时, `sum`减去这个和最小子数组等到`0`, `0`比`-1`大, 这样就出事了, 对于这种情况, 我们直接返回那个和最大子数组就行了

## 代码编写

```cpp
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n+1), g(n+1);
        int sum = 0;
        int fmax = INT_MIN, gmin = INT_MAX;
        for(int i = 1; i <= n; ++i)
        {
            int x = nums[i-1]; sum += x;
            f[i] = max(0, f[i-1]) + x;
            g[i] = min(0, g[i-1]) + x;
            fmax = max(fmax, f[i]);
            gmin = min(gmin, g[i]);
        }

        return gmin == sum ? fmax : max(fmax, sum - gmin);
    }
};
```

# 完

