# [乘积为正数的最长子数组长度](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/)

![image-20250405150532851](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405150532918.png)

## 题目解析

给你一个整数数组, 请从中找出一个子数组, 使得其元素乘积为正数, 并且长度最大化, 返回这个长度最长子数组的长度.

**示例一**

>```
>输入：nums = [1,-2,-3,4]
>输出：4
>解释：数组本身乘积就是正数，值为 24 。
>```

我们可以选择`[1]`作为乘积为整数的子数组, 长度为一, 亦可以选择`[1,-2,-3]`作为乘积为整数的子数组, 长度为三, 还可以选择`[1,-2,-3,4]`, 长度为四, 返回最长的长度, 4.

**示例二**

>```
>输入：nums = [0,1,-2,-3,-4]
>输出：3
>解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
>注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数
>```

我们可以选择`[1]`作为有效的子数组, 还可以选择`[1,-2,-3]`作为有效的子数组, 返回最长的三

**示例三**

>```
>输入：nums = [-1,-2,-3,0,1]
>输出：2
>解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。
>```

## 算法原理

- **状态表示**

  还是老样子, 我们定义`dp[i]`为以`i`为结尾的最长乘积为正数子数组长度, 但之后, 我们可以发现, 一维的`dp`不足以满足我们的需求, 为什么呢? 因为当`nums[i]`的状态(正数或者负数)不同时, 我们对于乘积为正数的子数组寻找策略将会发生变化, , 比如, 当`nums[i]`为负数时, 很明显, 我们应该在前面找乘积为负数的子数组, 因为负负才能得正, 而当`nums[i]`为正数时, 应该往前面找乘积为正数的子数组, 所以我们需要引入新的一维, 定义`f[i]`为以`i`为结尾, 乘积为正数的子数组的最长长度, `g[i]`为以`[i]`为结尾, 乘积为负数的子数组的最长长度. 

- **状态转移**

  对于以`i`为结尾的子数组, 大致有两种划分方式, 一是该子数组的长度为一, 或者说, 该子数组就是`nums[i]`自身, 另一种方式是该子数组的长度超过一, 此时就需要之前的状态信息.

  当`nums[i]`为正数时, 对于`f[i]`, 应该寻找前面最长乘积为整数的子数组, 因为子数组是连续的, 所以很明显, 这需要`f[i-1]`位置的帮助, 寻找的结果分为两种可能, 一是没找到, 也就是说, 前面没有乘积为正数的子数组, 那么, 此时这种情况就会退化为子数组长度为一的情况, 如果找到了, 那就是之前的最长长度再加上`nums[i]`自身的一长度. 

  当`nums[i]`为负数时, 对于`f[i]`, 应该寻找前面最长乘积为负数的子数组, 因为子数组是连续的, 所以就需要查询`g[i-1]`的数值以判断是否存在这样的子数组, 若`g[i-1]`的值为`0`, 即意味着不存在这样的子数组, 那么此时就会退化为长度为一的分支, 如果找到了, 那就是之前最长的长度再加上`nums[i]`自身的一长度.

  ![image-20250405154533552](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250405154533623.png)

  而对于`g[i]`, 亦是如此.

  当`nums[i]`为负数时, 应该要去前面找乘积为正的最长子数组, 能找到, 那就是找到的长度加上自身的一, 找不到, 它自身也可以做一个子数组, 长度为一

  当`nums[i]`为正数时. 应该要去前面找乘积为负的最长最数组, 能找到, 那就是找到长度再加上自身的一, 找不多, 它自身成不了乘积为负数的子数组, 长度为零

  当`nums[i]`为零时, 所有子数组乘积都归零, 所以长度都为零

- **初始化**

  建立虚拟位置, 对于第一个有效位置来说, 前面根本没有子数组, 更不用提子数组乘积为正或者负了, 因此, 虚拟位置的长度就是零, 代表前面没有乘积为正或者负的子数组

- **填表顺序**

  从左往右, 两表同填

## 代码编写

```cpp
class Solution {
public:
    int getMaxLen(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n+1);
        vector<int> g(n+1);
        int result = 0;
        for(int i = 1; i <= n; ++i)
        {
            int x = nums[i-1];
            int fmax = f[i-1];
            int gmin = g[i-1];
            
            if(x < 0)
            {
                f[i] = gmin == 0 ? 0 : gmin + 1;
                g[i] = fmax + 1;
            }
            else if(x > 0)
            {
                f[i] = fmax + 1;
                g[i] = gmin == 0 ? 0 : gmin + 1;
            }
            else
            {
                f[i] = 0;
                g[i] = 0;
            }

            result = max(result, f[i]);
        }
        return result;
    }
};

/*
	第二轮重写
    考虑到正数和负数想要乘上一个数并使得它们的积为整数, 所需要的要求是不同的
    所以首先可以肯定的是, 我们将会采用多状态dp来进行解题, 我们将会把积分为
    正数和负数两种, 我们定义dp[i]表示以i为结尾的子数组, 其元素的积为正数或者
    负数的最大长度, 其中dp[i][0]负责正数部分, dp[i][1]负责负数部分
    首先对于dp[i][0]来说, 如果nums[i]为正数, 那么前面再乘上一个正数就可以获得
    正数, 恰好dp[i-1][0]中存储的就是以i-1为结尾的乘积为整数的最长子数组长度,
    我们直接加上自身i的长度一就可以了 如果nums[i]为负数, 那么只要前面乘上一个负数
    就能获得正数, 所以就是dp[i-1][1]+1 如果是零, 那么乘上谁都不管用, 长度直接归零
    这样一来, 对于dp[i][0]就有
    if [i] > 0
        dp[i][0] = dp[i-1][0] + 1
    else if [i] < 0
        dp[i][0] = dp[i-1][1] + 1
    else
        dp[i][0] = 0

    同理, 对于dp[i][1]来说, 也有
    if [i] > 0
        dp[i][1] = dp[i-1][1] + 1
    else [i] < 0
        dp[i][1] = dp[i-1][0] + 1
    else
        dp[i][0] = 0

    另外, 还需要注意的一点是, 当上一个元素的状态位为0时, 如果本身是正数, 那么就乘不出负数, 对于负数也一样
    这样, 综合来看, 就有
    if [i] > 0
        dp[i][0] = dp[i-1][0] + 1
        if(dp[i-1][1] != 0)
            dp[i][1] = dp[i-1][1] + 1
    else if [i] < 0
        dp[i][1] = dp[i-1][0] + 1
        if(dp[i-1][1] != 0)
            dp[i][0] = dp[i-1][1] + 1

    返回值, 检索其中最大的dp[i][0] 

    考虑到长度顶多为零, 所以我们将uint32_t作为动规表的元素
    为了简化对于第一个位置元素的初始化过程, 我们在最前面引入
    一个虚拟位置
*/

class Solution {
public:
    int getMaxLen(vector<int>& nums) {
        uint32_t dp[100001][2] = {0};
        
        uint32_t ans = 0;
        int n = nums.size();
        for(int i = 1; i <= n; ++i)
        {
            if(nums[i-1] > 0)
            {
                dp[i][0] = dp[i-1][0] + 1;
                if(dp[i-1][1] != 0)
                    dp[i][1] = dp[i-1][1] + 1;
            }
            else if(nums[i-1] < 0)
            {
                dp[i][1] = dp[i-1][0] + 1;
                if(dp[i-1][1] != 0)
                    dp[i][0] = dp[i-1][1] + 1;
            }
            
            ans = max(ans, dp[i][0]);
        }

        return ans;
    }
};
```

# 完

