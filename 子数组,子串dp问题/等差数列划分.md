# [等差数列划分](https://leetcode.cn/problems/arithmetic-slices)

![image-20250406094103434](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250406094103508.png)

## 题目解析

给你一个整数数组, 该数组里有若干个子数组, 请你找出其中可以构成等差数列的子数组, 返回满足要求的子数组个数.

**示例一**

>```
>输入：nums = [1,2,3,4]
>输出：3
>解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。
>```

**示例二**

>```
>输入：nums = [1]
>输出：0
>```

**示例三**

>输入：nums = [1,2,3,6,9]
>输出：2
>解释：nums 中有三个子等差数组：[1, 2, 3]、[3, 6, 9]。

## 题目解析

- **状态表示**
  题目要求我们找出可以构成等差数列的子数组, 那我们要先把子数组给找出来, 然后从里面筛出可以构成等差数列的子数组个数, 为此我们可以定义`dp[i]`为以`nums[i]`为结尾的子数组中可以构成等差数列的子数组.

- **状态转移**
  动态规划有时候是找重复性子问题. 这里我们定义`dp[i]`为以`i`位置为结尾的所有子数组中可以构成等差数列的子数组个数, 是想让`i`位置继承`i-1`的属性, 把问题"以`i`位置为结尾满足要求的子数组个数"转化成"以`i-1`位置为结尾满足要求的子数组个数"这样的子问题. 如果以`i-1`位置为结尾已经构成等差数列, 而`i`位置也可以和`i-1`, `i-2`位置构成等差数列, 那么`i`位置就能继承之前`i-1`位置的属性, 比如之前是`[1,2,3]`现在来了一个`4`, `4`和`[2,3]`可以构成等差数列, 那`[1,2,3,4]`很明显也可以构成一个等差数列, 因此对于`4`来说, 以它为结尾的满足要求的子数组有两个渠道, 一是从之前的`3`身上继承`[1,2,3]`从而构成`[1,2,3,4]`, 另一个渠道, 是因为自己的到来, 而创造出一个新的等差数列`[2,3,4]`, 第二个渠道有着固定的个数, 而且也是第一个渠道, 或者说`4`继承`3`属性的条件, 如果`[2,3,4]`无法构成等差数列, 那`4`就无法继承`3`之前的属性, 因为子数组是连续的, 你末尾这部分都构成不了子数组, 那`3`之前的属性对于`4`也就没用了.
  现在我们把数字换成字母, 对于`i`位置(记为c)来说, 我们先看它的前两个位置(记为a,b), 先看`[a,b,c]`是否可以构成等差数列,  如果不能构成, 那说明`b`的属性和`c`没有关系, 所以以`c`为结尾的满足要求子数组个数就是零,    如果能构成, `[a,b,c]`自身就是一个等差数列,你需要记录这个"1",  接着你需要记录从`b`继承下来的子数组个数, 以`b`为结尾的满足要求的子数组后面再加上一个`c`, 那也是一个等差数列.
  ![image-20250406103417019](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250406103417100.png)

  综上, 状态转移方程为`dp[i] = c - b == b - a ? dp[i-1] + 1 : 0;` 

- **初始化**

  这次我们就不建立虚拟位置了,  而是直接初始化了, 很明显, 由于以`0`, `1`为下标的子数组个数都凑不到3个, 所以必然不是等差数列, 初始化为零

- **填表顺序**
  从左往右

- **返回值**

  题目要的是所有, 所以我们要把每个位置的值累加.

## 代码编写

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) { 
        int n =nums.size();
        vector<int> dp(n);
        int result = 0;
        for(int i = 2; i < n; ++i)
        {
            int c = nums[i];
            int b = nums[i-1];
            int a = nums[i-2];
            dp[i] = c - b == b - a ? dp[i-1] + 1 : 0;
            result += dp[i];
        }
        return result;
    }
};
```

# 完



