# [地下城游戏](https://leetcode.cn/problems/dungeon-game)

![image-20250402093525276](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402093525464.png)

## 题目解析

给你一个`m*n`大小的矩阵, 该矩阵描述了一个由恶魔把守的地下城.   恶魔们抓走了王国的公主, 并将她囚禁在地下城的右下角`[m-1, n-1]`, 为了拯救公主, 王国派出了一位骑士. 这位骑士将从地下城的右上角`[0,0]`开始, 穿过地下城, 最终来到`[m-1, n-1]`救回公主.

地下城的每个格子有三种可能, 一, 格子里有恶魔把守(格子数值为负数), 骑士进入会与恶魔开打, 从而降低自身的生命点数, 二, 格子里什么都没有(数值为零), 骑士进入既不会扣血, 也不会加血,   三, 格子里有血包(数值为正数), 骑士进入可以吃到血包从而增加自身血量.当骑士的血量下降到零或者零以下后, 就会死亡.

由于力量有限, 骑士决定每次移动, 只向右或者向下走一个格子.          

返回确保骑士能够拯救到公主所需的最低初始生命点数.

注意: 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

**示例一**

>```
>输入：dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
>输出：7
>解释：如果骑士遵循最佳路径：右 -> 右 -> 下 -> 下 ，则骑士的初始健康点数至少为 7 。
>```

![image-20250402110559488](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402110559557.png)

我们先随便找个值来试, 比如说, 假设骑士的起始值为3, 先进入第一个格子, 出来变成1, 然后我肯定走的是扣血更小的那一个, 所以我们选`-3`, 进入之后, 出来变成负数-2, 这意为着我们死在里面了, 所以看起来初始值为3不行, 那我们换一个值, 比如说, 我们最开始的值为6, 6进-2得4, 4进-3得1, 1进3得4, 4进1得5, 5进-5得0, 0意为着死亡, 所以我们在公主面前死了.           7我就不试了.

**示例二**

>输入：dungeon = [[2,3,-4],[2,-1,2]]
>输出：1
>解释：骑士可以遵循两条路径: 下 -> 右 -> 右     或者  右 -> 下 -> 右    它们的初始健康点数都为1

![image-20250402111950749](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402111950788.png)

对于这个示例来说, 因为血包比较多, 所以不仅最低初始血量为一, 而且有两条路径可以满足要求. 

按照第一种, 即 下 -> 右 -> 右  的路径, 骑士的血量状况是这样的

![image-20250402112333634](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402112333675.png)

按照第二种, 即 右 -> 下 -> 右 的路径, 骑士的血量状况是这样的

![image-20250402112557270](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402112557311.png)

## 算法原理

- **状态表示**

  对于路径问题的一般思路是, 要么以当前时间点为结尾, 向前回溯相邻的状态, 即我们常说的以`[i,j]`为结尾, 什么什么,  要么以当前时间点为开始, 向后推导相邻的状态, 即我们常说的以`[i,j]`为开始, 什么什么,    
  
  好, 我们先看以某个位置为结尾, 这种情况. 此时`dp[i][j]`表示: 从起点开始, 到达`[i,j]`位置的时候, 所需的最低初始生命点数.
  
  对于这种思路来说, 其实不太好解决, 首先, 是初始化问题, 我们就先不引入虚拟位置, 仅看起始的开始位置, 最开始, 与它对应的`dp`该初始化为什么呢? 即使完成了初始化, 那如果之后我发现以这个值为开始的生命点数,到达不了, 就是中途血量变成非正数了, 此时, 又该如何处理? 难道再找一个值重新试吗? 或许它也是可以走得通的, 但可能不太好走, 因为它的状态转移方程很不好表述
  
  接下来我们看看另一个思路, 此时,  `dp[i][j]`表示: 从`[i,j]`开始, 到达起点所需要的最低生命点数. 
  
- **状态转移**

  当我们已经到达`[i,j]`后, 有两种走法, 一是往右走, 二是往下走. 不过, 需要注意的是, 你还不能直接走, 你必须承受完`[i,j]`这个格的代价之后, 再继续往下走.    只有你出`[i,j]`这个格子后, 生命值还大于等于之后格所需要的最低生命点数(也就是`dp[i+1,j], dp[i][j+1]`), 那才说明我可以继续往这条路径下面走, 此时得到的`x`(记`x`为`dp[i][j]`的一种可能)表达式就是
  $$
  x + dungeon [i][j] ≥ dp[i][j+1]
  $$

  $$
  x + dungeon [i][j] ≥ dp[i+1][j]
  $$

  
  $$
  x ≥ dp[i][j+1] - dungeon [i][j]
  $$

  $$
  x ≥ dp[i+1][j] - dungeon [i][j]
  $$
我们要的是最小值, 所以
$$
x_1 = dp[i][j+1] - dungeon [i][j]
$$

$$
x_2 = dp[i+1][j] - dungeon [i][j]
$$

$$
dp[i][j] = min(x_1, x_2)
$$
​		不过我们还需要注意一个细节问题, 那就是$x_1, x_2$是可能为非正数的, 但很明显, 我们的血量不能为非正数, 所以对于这种情况我们需要把它们修正为最小的		血量, 也就是1. 
$$
dp[i][j] = min(x_1, x_2) = min( dp[i][j+1],  dp[i+1][j]) - dungeon [i][j]
$$

$$
dp[i][j] = max(1, dp[i][j])
$$

​		我们这里的表达式是推出来的, 但我们实际上也可以赋予它们一定的实际意义. 

​		比如我们之前的这个例子: 

​		![image-20250402111950749](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402111950788.png)

​		与之对应的`dp`表就是

​		![image-20250402134442938](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402134443002.png)

​		我们看`[1][2]`回溯到`[1][1]`, `1 - -1`得2, 是正数, 所以我们就是正数, 以`[0,1]`为开始, 它有两条路径可以选择, 一是, `5 - 3`得2, 二是`2 - 3`得-1,  对		于这种情况, 我们肯定是选负数的那条路径, 都是同一个减数, 它凭什么小呢? 甚至都小到负数, 这是因为被减数小, 被减数代表的是下一个格的最小点数, 那		我肯定选择, 更小的点数格子. 当然此时得到的生命点数是负数, 所以我们需要和1这个理论最小的生命点数作比较, 得出一个合法的点数,               接下来, 		我们以`[0][0]`为开始, 这时候, 一条路径所需要的理论最小点数是`1 - 2`得-1, 对于这种两个理论最小值都是非正数的情况, 你选哪一条走都可以, 因为它		们最后都要被修正为1. 所以其实是一样的.

- **初始化**

  对于上面的状态转移方程来说, 其实我还可以用另一种表示方法, 那就是先把$x_1, x_2$单独求出来, 然后对其中的非正数进行修正, 修正为1, 然后再取其中的最小值, 但我并没有这种表述, 因为这种表述它不够简洁, 状态转移方程简洁的好处就是方便我们确定虚拟位置该如何初始化, 很明显, 对于本题来说, 肯定是要增加一行和一列虚拟位置的, 这就引发了虚拟位置如何初始化的问题.

  ![image-20250402140844984](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402140845025.png)

  先看终点位置, 对于终点位置来说, 我们只要出来之后还活着就行了, 所以它周围的格初始化为1就行了. 至于其它位置, 我们想要达到的效果是它们虽然参与状态转移, 但绝不会被真正使用.      根据状态转移方程, 我们实际选择的那一条路径, 其实是被减数(也就是`dp[i][j+1] or dp[i+1][j]`), 更小的那一条路径, 所以如果我们不想让这个路径被选中, 只要让它的`dp`值大到无法被选中就行了.      另外还要说一点, 如果采用我们舍弃的那个状态转移表述方式(先修正, 再取最小), 容易发生数值溢出问题, 你就需要再额外考虑.

  ![image-20250402142221425](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402142221460.png)

- **填表顺序**

  从右往左, 从下往上. 依靠依赖关系得出

- **返回值**

  `dp[0][0]`

## 代码编写

```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int m = dungeon.size(), n = dungeon[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
        dp[m][n-1] = dp[m-1][n] = 1;
        for(int i = m-1; i >= 0; --i)
        {
            for(int j = n-1; j >= 0; --j)
            {
                int temp = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j];
                dp[i][j] = max(1, temp);
            }
        }
        return dp[0][0];
    }
};
```

# 完
