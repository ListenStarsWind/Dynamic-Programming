# [最小路径和](https://leetcode.cn/problems/minimum-path-sum)

![image-20250401194448244](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250401194448405.png)

## 题目解析

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例二**

>```
>输入：grid = [[1,2,3],[4,5,6]]
>输出：12
>```

![image-20250401195044646](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250401195044684.png)

## 算法原理

- **状态表示**

  本题还是一个经典的路径问题, 对于该种类型的动规题目, 常用的状态表示就是从起点开始, 到达`[i,j]`位置的某种状态, 根据题意, 可知, 这里的某种状态是此时的最小路径和, 所以`dp[i][j]`表示从起点到达`[i][j]`位置的最小路径和.

- **状态转移**

  因为我们只能向下或者向右走一格, 所以对于`[i,j]`位置来说, 之前的相邻状态要么是位于`[i-1,j]`, 要么是位于`[i,j-1]`, 如果位于`[i-1,j]`, 那么此时的路径和不就是`[i-1,j]`的最小路径和再加上`[i,j]`位置自身吗? 而`[i-1,j]`位置的最小路径和不就是`dp[i-1][j]`吗? 同理, 如果位于`[i,j-1]`, 那么此时的路径和不就是`[i,j-1]`的最小路径和再加上`[i,j]`位置自身吗?而`[i,j-1]`位置的最小路径和就是`dp[i,j-1]`, 这两种情况选择其中最小的那一个就行了. 所以我们的状态转移方程就是

  `dp[i][j] = grid[i][j] + min(dp[i-1][j] + dp[i][j-1])`.

- **初始化**

  还是和之前一样, 在填表过程中, 我们可能会遇到很多越界情况, 为此需要加一些虚拟位置.

  ![image-20250401200550515](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250401200550562.png)

  接下来我们来看初始化问题. 我们先依据实际情况, 求出它们应该是的数值, 此处以示例一为准

  ![image-20250401200729887](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250401200729934.png)

  首先对于起点来说, 它就应该为它自身, 这意味着它在被状态转移方程推导时, 那个`min`结果应为零, 这样的话, 起点格周围的格子就应该为零

  ![image-20250401200943369](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250401200943419.png)

  对于虚拟位置来说, 它只能参与`min`的比较, 但不能被真正使用, 为此, 对于其它的虚拟格, 应该将其初始化为`INT_MAX`, 这样`min`就不会真的返回它们.

- **填表顺序**

  老样子, 从左往右, 从上往下

- **返回值**

  即为与终点对应的`dp`格子, 即`dp[m][n]`

## 代码编写

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
        dp[0][1] = 0; dp[1][0] = 0;
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                int temp = min(dp[i-1][j], dp[i][j-1]);
                dp[i][j] = grid[i-1][j-1] + temp;
            }
        }
        return dp[m][n];
    }
};
```

# 完