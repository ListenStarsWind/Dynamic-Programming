# [不同路径](https://leetcode.cn/problems/unique-paths)

![image-20250331135110426](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331135110509.png)

## 题目解析

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步. 或者说, 对于一个方格来说, 机器人要么从左边的邻近格过来, 要么从上面的邻近格过来. 机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

**示例二**

我们不看示例一, 因为格子太多了, 不好画.

>```
>输入：m = 3, n = 2
>输出：3
>解释：
>从左上角开始，总共有 3 条路径可以到达右下角。
>1. 向右 -> 向下 -> 向下
>2. 向下 -> 向下 -> 向右
>3. 向下 -> 向右 -> 向下
>```

![image-20250331135946898](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331135946927.png) ![image-20250331140015360](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331140015389.png) ![image-20250331140111258](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331140111287.png)

## 算法原理

- **状态表示**

  很明显, 这是一个二维化的发展过程, 找路径它是二维化的.     

  我们依据经验结合题目具体要求, 认为`dp[i][j]`是以什么什么为结尾的.    或者说, `dp[i][j]`所代表的事件是从起点走到`[i, j]`位置, 然后结合题目要的是有多少路径, 所以我们规定, `dp[i][j]`表示从起点开始, 走到`[i, j]`位置, 一共有多少种方式

- **状态转移**

  还是之前的样子, 我们研究与当前状态相邻的状态转移到当前状态的过程.

  当前状态是位于`[i, j]`位置. 由于它只能往下走或者往右走, 所以对于`[i, j]`位置来说, 他之前要么位于`[i-1, j]`, 要么位于`[i, j-1]`. 

  ![image-20250331141722360](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331141722411.png)

  如果它是从`[i-1, j]`到`[i, j]`的, 如果需要知道路径的个数, 我们只需要知道起点到`[i-1, j]`有多少条可能的路径就行,即`dp[i-1, j]`, 需要注意的是, 不要加一, 因为最后一步已经确定了

  如果它是从`[i, j-1]`到`[i, j]`的, 同理, 对应的路径数就是`dp[i, j-1]`. 

  在上面我们已经分析了`[i, j]`两种可能的邻近状态, 接下来我们把这两种分支的情况加起来就得到了总的路径个数, 这样就得到了状态转移方程.

  `dp[i][j] = dp[i, j-1] + dp[i-1, j]`.

- **初始化**

  我们知道初始化的作用是让填表不越界, 当我们位于网格的边界时, 就会发生越界

  ![image-20250331142915523](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331142915563.png)

  为此我们有两种初始化方式, 一是把图中标记的格全部填成`"1"`, 因为边界上的格子, 只能一直向右或者向下才能到达, 另外一种初始化方式, 也是我们这里采用的初始化方式, 就是增加虚拟位置.

  ![image-20250331143452498](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331143452540.png)

  增加虚拟位置是要进行多余考虑的, 一方面, 你要处理好下标的映射关系, 另一方面, 你要想想虚拟位置上该填什么, 才能让原先边界的那些格子都能依据状态转移方程的到正确的结果. 如果把虚拟位置都定位`"1"`或者`"0"`, 感觉都不对, 所以我们要找一个特别位置作初始化. 比如, 这里我们可以在起点的左边或者上边的虚拟位置填为`"1"`.

  ![image-20250331144022626](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331144022667.png)

  这样的话, 起点就会被初始化为一, 然后和初始化相邻的边界格就会因为起点也被初始化为一, 从而将一连续传递下去.

- **填表顺序**

  依据状态转移方程, 可知, 要计算当前的位置, 需要知道它上边和右边的值, 所以我们的初始化顺序就是从左往右, 逐行向下的填表.

- **返回值**

  易知, 应为`dp[m][n]`, 这里是右下角.

## 代码编写

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n+1));
        dp[0][1] = 1;
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m][n];
    }
};
```

# 完

