# [移除盒子](https://leetcode.cn/problems/remove-boxes/)

![image-20250526162418214](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250526162418355.png)

## 算法原理

这又是一道消消乐, 由于在之前我写过另一个消消乐, 就是本专题的上一道题, 祖玛游戏, 所以我一开始就在困惑, 该如何实现, 之前决策对当前决策的影响, 消消乐吗, 消除就没有了, 所以现在的状态依赖于之前的状态, 在最开始时, 我所采用的是纯粹的模拟策略, 将一个`pair<int, int>`的数组作为每个栈帧的参数, 这个`pair`描述的是, 数值相同的连续区间长度和数值, 在数组中, 相邻的`pair`表示相邻的区间.

于是我们可以尝试一个个挪去数组中的`pair`, 比如, 挪去`i`位置的`pair`, 然后看看`i-1`和`i+1`的`pair`能不能合并, 数值相同则合并区间长度, 以此构建出来一个新的数组, 传递给下一个栈帧. 为了实现对数组参数的记忆化搜索, 受到最近经常遇到的字符串类问题, 我们将其中的元素拼成一个完整的字符串, 作为`key`.最后的结果是超时.

接下来我们说说官解. 官解的宏观思路基于一个朴素的想法, 很显然, 个数一定是大于等于1的, 所以, 我们应该尽可能地把数值相同的元素聚集到一起, 让它们集中消除, 从而获得更大的区间长度, 更高的分数, 为了让这些相同的数值聚集到一起, 我们需要先删除隔开它们的那些中间的区间.

我们尝试把数组分成两个部分, 一个部分的区间是`left, right`, 另一个区间中含有`k`个和`nums[right]`相同的数, 本着聚集的思想, 我们对于第二个区间中的其它元素已经都清除了, 也就是说, 现在, 第二个区间中只剩下`k`个数, 且它们的值都是`nums[right]`

这样的话, 对于`dfs(left, right, k)`来说, 我们就有了一个基础分数, 那就是将`nums[right]`和它后面的`k`个数, 这`k+1`长度的区间一次性消除, 这样我们就能获得`pow(k+1, 2)`的分数, 在这之后, `right-1`就成为了新的末尾位置, 它后面的元素现在都被清除了, 所以的话, 显而易见, 既然它后面都没有数了, 那么自然就是`dfs(left, right-1, 0)`.   这种选择是一定存在的, 所以我们将其称之为基础分数.

但是, 可能在`right`的前面, 也存在一些元素, 和`nums[right]`相同, 但我们并没有把它们聚集上来, 所以我们可以在`left, right-1`找这样的一个数`nums[i]`, 使得`nums[i]`和`nums[right]`相同, 这样的话, 我们就可以把它们中间的区间`i+1, right-1`先给消除, 此时, 对于`nums[i]`来说, 因为`nums[right]`在其的后面, 所以`nums[i]`后面的, 与`nums[i]`相同的元素将有`k+1`个.我们可以传递到下一轮栈帧中进行计算. 所以对于这种选择来说, 会有两个分数的来源, 首先, 你应该把`i+1, right-1`这段中间区间清除掉, 对于`nums[right-1]`来说, 他后面除了`nums[right]`就是那`k`个数了, 没有和`nums[right-1]`相同的数字, 所以这方面额分数就是`dfs(i+1, right-1, 0)`, 当然, 你可能会有这种疑惑, 是的, 应该将相同的数值放到一块, 可, `i+1, right-1`这个区间里是否会存在也和`nums[right]`相同的数呢? 那这样的话, 最后一个参数填`0`似乎并不合适, 对于这种疑惑, 首先需要说的是, 填`0`就是合适的, 它并没有什么不合适的地方, 因为我们是为了让`i`和`right`这两个位置相邻才选择删除中间的部分, 这样就能构建出一个`nums[i]` + `k+1`个的`nums[i]`区间, 所以说, 这意味着, 在消除`i+1, right-1`的时候, 我们不能使用`right-1`后面的元素, 因此第三个参数就是零.   或者也可以从另一个角度来考虑, 我们的`i`是在`left, right-1`区间移动的, 假如之后真的存在和`nums[right]`相同的元素, 那在之后必定会命中, 于是我们就会最终选出这样的一个`nums[i]`, 它是距离`nums[right]`最近的相同元素, 此时它就会将`nums[right]`和`k`个数的状态传递下去, 并最终使得所有的`nums[right]`聚集在一起.      第二个可以得分的方面是, 在消除`i+1, right-1`之后, 就剩下了两个部分, 一是`left, i`这个区间, 二是这个区间后面`k+1`个`nums[i]`(`nums[right]`也加入到了其中), 对应的是`dfs(left, i, k+1)`.

既然有三个参数, 并且题目也说了, 最多100个数, 所以我们就可以用一个三维矩阵来作为`dp table`, 然后就没有然后了.

还有一个小优化, 就是说, 可能, 对于`nums[right]`来说, 可能它前面, 也有一段与之直接相邻的相同区间, 此时我们就可以把`right`移到该前驱区间的首元素, 然后再执行上述的推导.

## 代码编写

```cpp
class Solution {
    int size;
    int dp[100][100][100] = {0};

    int dfs(int left, int right, int k, const vector<int>& boxes)
    {
        if(left > right) return 0;

        if(dp[left][right][k] == 0)
        {
            // right前面可能是一段和[right]相同的连续区间, 对于这些
            // 区间, 我们可以直接归类到k中, 从而让k^2变得更大
            int _r = right, _k = k;
            while(_r > left && boxes[_r] == boxes[_r-1])
            {
                ++_k;
                --_r;
            }

            // 在之前的过程中, 我们发现, boxes[right]的右边有k个相同的元素
            // 所以我们之前我们做了这样的决策, 先把right位置后面的部分中除去
            // 那k个boxes[right], 之外的所有元素, 我们都想办法清除了, 也就
            // 是说, 现在, right后面只剩下了k个元素, 他们都是boxed[right]

            // 决策一, 我们不考虑right左边的情况, 直接把right和后面的k个数消除
            // 这样的话, right-1将成为序列中新的末尾, 它后面没有任何元素
            // 所以接下来我们只需要在left, right-1区间继续考虑
            dp[left][right][k] = dfs(left, _r - 1, 0, boxes) + pow(_k+1, 2);
            
            // 决策二, 我们看看right左边是否还存在与之相同的元素, 如果存在这样的元素
            // 我们就先把right以及它后面的k个元素保留下来, 先去清除中间部分的区间
            for(int i = left; i < _r; ++i)
            {
                if(boxes[i] == boxes[_r])
                {
                    dp[left][right][k] = max(dp[left][right][k], dfs(left, i, _k+1, boxes) + dfs(i+1, _r-1, 0, boxes));
                }

                // 可以预见, 那个离right最近的相同[i]将会将z左边传递下去, 最终将数组中所有的[right]都集齐
            }
        }
        
        return dp[left][right][k];
    }
    
public:
    int removeBoxes(vector<int>& boxes) {
        size = boxes.size();
        return dfs(0, size-1, 0, boxes);
    }
};
```

# 完

