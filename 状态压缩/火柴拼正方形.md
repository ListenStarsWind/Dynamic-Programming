# [火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)

![image-20250521194556130](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250521194556384.png)

## 算法原理

我们有两个解法, 在这两个解法之前, 我们都要先进行一下预处理操作, 试想一下, 既然它是正方形, 那么每个边当然都是相同的, 并且我们还必须用上所有的火柴, 所以火柴的总长就是正方形的总长, 总长除以4, 那得到的就是边长. 

如果边长是小数, 很显然, 这意味着它必然拼不出正方形, 所以我们直接返回`false`即可. 如果不是, 那就需要具体解法了.

此时我们的问题其实已经被转化成了另一个问题, 那就是现在有一个整数数组, 给你一个目标值, 问你, 能不能把数组中的元素分成四个部分, 每个部分的元素和都是给定值.

首先我们看一下第一种解法, 这个解法并不是我们的重点, 既然我们有四个边需要被填充, 那么我们就先放一个大小为四的数组, 表示每个边的当前长度, 然后我们从第一个火柴开始, 一个火柴一个火柴的去试, 因为我们每个火柴都需要用上, 所以假设它确实能拼出一个正方形, 那么每个火柴都会被填充到四条边中的其中一条

当这个火柴加上某个边的当前长度, 不会超过边长时, 因为题目要求不能折火柴, 所以比如边长是8, 现在已经有6的长度, 再来一个6长度的火柴, 肯定是不可能拼上的, 出现这种情况, 要么是这个火柴确实不应该放在这里, 又或者是前面的火柴放错了, 影响到了这里, 此时我们的这根火柴就不能选择这条边, 而要选择其他的边, 如果一根火柴, 在当前的四条边都没有归宿, 那么要么说明前面的火柴放错了, 要么说明这些火柴其实根本拼不出来正方形, 此时我们就需要回溯到上一层, 告诉上一层, 你这一层的火柴放法是不可行的, 你看能不能换一个边放, 如果到最后, 第一个火柴都找不到合适的位置, 就说明真的拼不出来, 于是返回`false`.

```cpp
class Solution {
    int len;
    int lens[4] = {0};

    bool dfs(int idx, const vector<int>& nums)
    {
        if(idx == nums.size())
            return true;

        for(int i = 0; i < 4; ++i)
        {
            lens[i] += nums[idx];
            if(lens[i] <= len && dfs(idx + 1, nums))
                return true;

            lens[i] -= nums[idx];
        }

        return false;
    }

    public:
    bool makesquare(vector<int>& matchsticks) {
        int n = matchsticks.size();

        int sum = 0;
        for(auto e : matchsticks) sum += e;

        if(sum % 4) return false;

        len = sum / 4;

        sort(matchsticks.begin(), matchsticks.end(), greater<int>());

        return dfs(0, matchsticks);
    }
};
```

接下来是第二种方法, 我们发现, 火柴的总数其实比较少, 最多就15个, 我们先不要想那么多, 现在从这些火柴中取出一些火柴, 有多少种可能, 很明显, 每根火柴有选或者不选两种可能, 现在一共有`n`根火柴, 那么一共就有$2^n$种不同的搭配方案, 也就是说, 我们可以用比特位的形式来描述火柴搭配的所有可能, 1 表示选择, 0表示不选.

与第一种解法, 火柴找边的方式不同, 第二种解法是边找火柴, 既然从$[0, 2^n-1]$这$2^n$个数对应的二进制序列, 表示了所有的火柴搭配方案, 那么我们一个个试不就行了, 我们依据其中的某个数, 看看能不能用其对应的搭配方案拼出一条边.  我们有四个边, 当一个边的长度等于边长时, 我们就来到了下一个边, 由于是刚来到下一个边, 所以对应的长度是零.

假设我们现在已经得到了表示火柴搭配的一个整型`s`, 那么我们可以从中取出一个火柴, 当取出一个火柴的长度加上取出火柴的长度是小于等于边长的, 及说明可以采纳这个方案.  比如说, 现在的`s`是`0000 0100 1011`表示取了第一根(下标为零), 第二根(下标是一), 第四根(下标是三), 第七根(下标是六) 如果我们从中取出一个火柴, 就比如说是第七根, 那么对应的状态序列就是`0000 0000 1011`, 假设这根火柴长度是2, 边长要求是8, 现在已经有5, 那么加上这根火柴使得边长变成7就可能是可行的, 所以我们可以保留这一状态, 直接跳出循环, 为什么可以直接跳出了, 一方面, 可能有很多根相同的火柴, 有可能刚刚我们取出的火柴就是其中之一, 所以我们不用尝试另一种方案, 另一方面, 这四条边具有对称性, 所以说, 如果这个火柴可以放到这条边, 所以说不定也可以放到另一个边.所以只要有一个可行方案我们就直接退出循环, 找下一个状态.                         另外也有可能出现这种情况, 那就是没有一种方案能够使得该搭配方案存在下去, 或者更明显的说, 你不管从这个搭配方案里取出哪根火柴, 要么是直接的状态直接不可用, 要么是它们的当前边加上对应的火柴长度后都超过了边, 此时这种搭配就是不可选的, 我们用-1表示它不可选, 所以在判断之前的搭配方案加上火柴长度是否小于等于边长是, 你还应该判断一下之前的状态是否合法.

现在我们说一个依赖顺序问题, 由于我们是把一个二进制序列的其中一位一变成零, 所以我们便会丧失这一位的位权, 比如之前我们去掉了第七根火柴, 那么就必然失去了$2^6$, 这是显而易见的, 因为二进制序列转十进制, 是是加上为一的那些位的权重. 所以之前的状态天然小于现在的状态, 所以我们的推导顺序应该是从小到大.

对于最后一个数字, 即下标是$2^n-1$的第$2^n$个数, 它对应的状态是使用所有的火柴, 其只有两种情况, 一是等于零, 等于零意味着我们拼好了当前边, 并且我们用了所有的火柴, 我们的边是根据总和求出来的, 所以这意味着必然所有的边都已经拼成, 所以返回`true`, 另外一种情况是等于`-1`, 表示它是一个非法的搭配, 不会出现第三种可能, 因为它已经用了所有火柴, 而出现第三种情况意味着有些边正在拼, 还没拼完, 这是自相矛盾的, 所以是不可能的情况.

## 代码编写

```cpp
class Solution {
public:
    bool makesquare(vector<int>& nums) {
        int sum = 0;
        for(auto e : nums) sum += e;

        if(sum % 4) return false;

        int len = sum / 4;
        int n = nums.size();

        vector<int> dp(1 << n, -1);
        dp[0] = 0;
        for(int s = 1; s < (1 << n); ++s)
        {
            for(int k = 0; k < n; ++k)
            {
                // 小心优先级
                if((s & (1 << k)) == 0) continue;

                int s1 = s & (~(1 << k));
                if(dp[s1] != -1 && dp[s1] + nums[k] <= len)
                {
                    // %的意思就是==len 变成0 来到下一边
                    // < 还留在当前边
                    dp[s] = (dp[s1] + nums[k])%len;
                    break;
                }
            }
        }

        // 小心优先级
        return dp[(1 << n) - 1] == 0;
    }
};
```

# 完

