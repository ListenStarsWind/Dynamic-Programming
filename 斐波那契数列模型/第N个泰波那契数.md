# [第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number)

![image-20250329203832739](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250329203832854.png)

## 专题前言

今天我们进入了一个全新的章节, 那就是动态规划专题算法, 该算法有很多抽象的概念, 它本身也很难(难到中厂小厂都不会怎么考),为了让大家不至于从入门到入土, 我们在题目讲解过程中会尽量不提及这些专业术语, 而是带着大家一步步做题感受, 逐步加深对动态规划的理解. 

## 题目解析

现有一个泰波那契数列, 该数列的下标从零开始计数, 而不是数学上常见的从一开始计数, 已知, 泰波那契数列的起始状态是$T_0 = 0, T_1 = 1, T_2 = 1$, 对于题目中的"且在 n >= 0 的条件下$T_{n+3} = T_n +T_{n+1} + T_{n+2}$", 我们可以换种说法, "且在n >= 3的条件下, $T_n = T_{n-1} + T_{n-2} + T_{n-3}$" 这样可能看地更清楚. 给你整数n, 请你返回$T_n$的值.   需要注意, n 可能为0, 1, 2. 

比如说, 若n为三, 则有$T_3 = T_2 + T_1 + T_0 = 1 + 1 + 0 = 2$ 若n为四, 则有$T_4 = T_3 + T_2 + T_1 = 2 + 1 + 1 = 4$  若n为零, 则返回零

## 算法原理

对于动态规划算法来说, 一般可以用五步表示其具体思路, 它们分别是 "状态表示", "推导状态转移方程", "初始化", "填表顺序", "返回值表述".

- 状态表示

  正如动态规划的名字所言, 它并不是一次性计算出结果, 而是通过逐步推进的方式, 从简单的情况推导出复杂的情况, 也就是说, 它的过程可以简单的概述为, 用先前的历史状态推导出当前状态, 为此, 我们就需要通过某些方法, 保存, 记录先前的历史状态, 这正是状态表示的职责.

  本题的研究对象是一个数列, 对于数列来说, 很明显, 它可以用一维数组来表示, 数组中元素的下标就可以通过一些关系映射到数列中项的下标, 对于本题而言, 数列的下标就是从零开始, 所以数组元素下标就是数列项的下标

  因此, 如果现在要你求$T_n$, 我们就可以建立一个大小为n + 1 的整型数组, 来描述数列中项的状态, 进而描述先前的历史状态, 接下来, 我们要做的就是不断对该数组进行迭代, 最终把它填满.     这里稍微提一嘴, 对于表述状态的数据结构, 我们一般喜欢取名为`dp`, 其实就是动态规划的英文首字母缩写.

  我们这里的状态表示用的是一维数组, 但这并不是说, 动态规划的状态表示都是用一维数组, 对于具体该如何进行状态表示, 主要是要看个人经验和题目要求

- 状态转移方程

  如果说状态表示的职责是保存先前的历史状态, 那状态转移的职责就是告诉我们该如何用先前的历史状态推导出当前的状态, 所以它叫转移, 把状态从先前的时间点移到当前时间点.    对于本题而言, 状态转移方程就是 $T_n = T_{n-1} + T_{n-2} + T_{n-3}$, 用语言来表述就是, 现在的项, 就是它前面三个项的和.  如果说状态表示是动态规划的基础, 是最重要的一步, 那状态转移方程就是最难的, 因为它要你从题目那寥寥几行字里面, 总结出研究对象发展的一般普遍性规律. 

- 初始化

  事物的发展都遵循着一个因果链, 我现在为什么是这样一种状态, 那是因为你先前是那种状态, 所以导致了你当前状态的产生. 把当前状态不断往前推, 最终就会来到一个最初的起始状态, 至少对于我们日常世界是这样的, 所以在量子物理出现之前, 就有哲学家在思考, 既然事物发展有其因果链, 那宇宙创生这个最开始的事件是谁造成的呢? 好的, 我们不谈哲学了, 对于本题来说, 它最开始的状态, 就是$T_0 = 0, T_1 = 1, T_2 = 1$, 如果我们把$T_0 = 0, T_1 = 1, T_2 = 1$叫做"道", 那么状态转移方程就告诉我们, "道"是如何变成"一", "一"是怎么变成"二"的, "二"是怎么变成"三", "三"又是怎么生万物的, 没有"道", 就没有后面的"一, 二, 三, 没有万物",     从另一个角度来说, 我们状态转移方程 $T_n = T_{n-1} + T_{n-2} + T_{n-3}$是有条件的, 就是n >= 3, 你不把最开始的三个项填上, 它会越界的.

- 填表顺序

  事物不仅在不断发展, 其发展也是具有方向性的, 我们一般把这种方向性称之为"时间", 根据状态转移方程, 你这个事件必须在那个事件发生之后才能发生, 如果我这个时间点的状态, 要直接或者间接根据那个时间点的状态才能得到, 我就必须先推出那个时间点的状态, 你才可能退出这个时间点的状态, 不能倒着来, 就本题而言, 你要从左往右填表, 不要从右往左

- 返回值

  就是根据题目实际要求, 从状态表示结构里取一个答案状态, 对于本题来说, 就是`dp[n]`.

## 代码编写

对于动态规划的代码编写, 一般四步. "创建`dp`表,", "对`dp`表初始化", "填表", "返回",   注意处理一下n<3的边界情况

```cpp
class Solution {
    public:
    int tribonacci(int n) {
        if(n == 0) return 0;
        if(n == 1 || n == 2) return 1;

        int dp[n+1];
        dp[0] = 0, dp[1] = dp[2] = 1;
        for(int i = 3; i <= n; ++i)
        {
            dp[i] = dp[i-1] + dp[i-2]+ dp[i-3];
        }

        return dp[n];
    }
};
```

## 空间优化

一般情况下, 状态转移方程不需要之前的全部历史状态, 而只需要其中的一部分, 比如我们这里, 推导当前项需要前面的三个项, 所以我们其实不用真的开一个n+1的数组, 比如我们求$T_4$的时候, 不需要$T_1$了, 那就不用再记录了, 所以我们这里用四个整型就行了, a, b, c表示当前项的前三个项, d表示当前项, 用a, b, c求完d后, 我们把b赋给a, c赋给b, d赋给b就行了, 这相当于是大小为二的数组在之前的n+1大小数组上滑动, 所以有时候叫做滑动或者滚动数组.

```cpp
class Solution {
public:
    int tribonacci(int n) {
        if(n == 0) return 0;
        if(n == 1 || n == 2) return 1;

        int a = 0, b = 1, c = 1, d = 0;
        for(int i = 3; i <= n; ++i)
        {
            d = a + b + c;
            a = b; b = c; c = d;
        }

        return d;
    }
};
```

# 完