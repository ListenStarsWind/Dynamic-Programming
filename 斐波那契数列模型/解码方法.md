# [解码方法](https://leetcode.cn/problems/decode-ways)

![image-20250331100256408](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331100256629.png)

## 题目解析

一条只包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

`"1" -> 'A'
 "2" -> 'B'
 ...
 "25" -> 'Y'
 "26" -> 'Z'`

也就是说, 待会儿我们遇到的那个字符串中只会包含`'0'-'9'`这十种数字字符. 在编码时, 我们并没有在字母和字母之间设置分隔符, 所以在 **解码** 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（`"2"` 和 `"5"` 与 `"25"`）。

例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1, 1, 10, 6)`
- `"KJF"` ，将消息分组为 `(11, 10, 6)`

为了方便起见, 我们可以把分组中的每个元素称之为"字段", 如 `(1, 1, 10, 6)`中有四个字段, 它们分别是`"1", "1", "10", "6"`.请注意,  一个字段中不能含有前导零, 如`"06"`, 除此之外, 你还需要注意, 一个为零`"0"`的字段是不合法的, 因为字母`A-Z`没有任何一个字母映射到`"0"`上.

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。如果没有合法的方式解码整个字符串，返回 `0`。你不需要考虑数值溢出问题.

**示例 1：**

> ```
> 输入： s = "12"
> 输出： 2
> 解释： 首先, 我们可以将"12"看做两个字段, 它们分别是"1", "2", 于是就可以解码为"AB"
> 	  另外, 我们也可以将"12"看做一个字段, 即"12", 对应的字母为"L" 
> ```

**示例 2：**

> ```
> 输入：s = "226"
> 输出：3
> 解释：它可以解码为 "BZ" (2 26)[两个字段], "VF" (22 6)[两个字段], 或者 "BBF" (2 2 6)[三个字段] 
> ```

**示例 3：**

>```
>输入：s = "06"
>输出： 0
>解释：首先我们可以从s中解析出两个字段, "0", "6", 但"0"是一个非法字段, 所以这种分法被舍弃了,
>      其次, 我们可以将s整个视为一个字符段, 即"06", 但很明显, 它含有前导零, 因此也被舍弃了,
>      综上, 一共有0种解码方式
>```

## 算法原理

- **状态表示**

  对于动态规划来说, 状态表示其实主要是靠个人感觉(经验)和题目要求来确定的.   比如这里, 通过上面题目的解析, 我们大致可以感觉到它是一个线性的发展过程, 所以这里`dp`表用的还是一维数组, 至于`dp[i]`到底表示什么, 一般有两种思路, 一是以`i`位置为结尾, 依据题意怎么怎么样, 而是以`i`位置为开始, 依据题意怎么怎么样, 这里我们用以`i`为结尾的方式, 因为这是字符串, 解码应该是从左往右去连续地解, 所以以`i`为结尾比较合适. 

  ![image-20250331113942555](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331113942599.png)

  以`i`为结尾的意思就是, 我们的研究对象是从`s`(题目中给的那个字符串)的`0`号位置开始, 到`i`这个位置的子字符串, 研究它的什么属性呢? 既然题目问的是解码的方法数, 那么我们研究的就是该子字符串的解码方法数,    所以`dp[i]`表示, 从`s`的`0`号下标开始, 到`i`号的下标的这个子字符串的解码方法数.

- **状态转移**

  状态转移的一般思路是, 根据当前状态的临近状态进行问题分析. 

  比如对于我们这里的状态表示来说, 当前状态就是解码到`i`这个位置, 如果要解码`i`这个位置, 我们大体上有两套方案

  - 将`s[i]`自己视为一个字段, 进行单独解码
  - 将`s[i]`和`s[i-1]`视为一个字段, 进行解码

  ![image-20250331114953881](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331114953919.png)

  ![image-20250331115010314](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331115010350.png)

  为什么不往后找呢? 因为我们当前只研究绿色区域, 不看蓝色, 为什么不再去看`i-2`呢? 因为只有26种映射方式, 一个字段最多两位.    接下来我们要把这两套方案进行具体分析, 把这两套方案中获得的方法数相加就能得到整体的解码方法数.

  -------------

  **方案一**   将`s[i]`自己视为一个字段, 进行单独解码

  由于这个字段只有单个字符, 所以它肯定是`"0" - "9"`这十个字符中的某一个, 

  - 当它不为`"0"`, 这个字段就是合法的, 可以成功解析出字母,  此时就相当于前面`0`到`i-1`位置的字符串后面又加了一个字符, 所以对于这种情况, 我们能获取的解码方法数就是前面`0`到`i-1`位置的字符串的解码方法数, 即`dp[i-1]`
  - 当它为`"0"`时, 这个字段就是非法的, 也就是说, 这种解码方式是行不通的(即使是你前面的字符被成功解出, 也会因为最后这个字符无法解析而整体失败), 你不能这样解码, 所以我们从这种情况下可以获得0个方法数.

  ------------

  **方案二**   将`s[i]`和`s[i-1]`视为一个字段, 进行解码

  - 当这两个字符表示`"10"`到`"26"`之间时(不允许前导零, 所以必须大于9), 解码成功, 此时就相当于 前面`0`到`i-2`位置的字符串后面又加了一个字符, 我们能从这种情况下获取`dp[i-2]`的方法数
  - 其它情况下, 字段是非法的, 由于这两个字符无法被解析, 所以会导致先前的解码也失败, 所以从这种请情况下, 能获取的方法数为0.

  -----------

​	综上, `dp[i]` = `dp[i-1]`(存疑, 也有可能为零) + `dp[i-2]`(存疑).

- **初始化**

  初始化有两种方式, 我们先用思路更清晰的:

  根据状态转移方程, 可知, 可能用到当前位置的前两个位置, 所以最开始需要对`dp[0]`和`dp[1]`进行初始化

  对于`dp[0]`来说, 它身为单个字符, 也就两种可能, 一是`"1"`到`"9"`, 解码成功, 有一种方法, 二是`"0"`, 非法, 为零.

  对于`dp[1]`来说, 有两个字符, 那么就有两种方案, 一是把它们分成两个字段分别解析, 当两个字段都合法时, 那这种方法就是可行的, 就能获得一个方法数, 二是把这两个字符整个当做一个字段, 当该字段合法时, 意为着它是可行的, 就能获得一个方法数.

- **填表顺序**

  由状态转移方程可知, 应该是从左往右

- **返回值**

  易知, 为`dp[n-1]`

## 代码编写

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n);
        if(s[0] != '0') dp[0] = 1;
        if(n == 1) return dp[0];
        int num = (s[0] - '0') * 10 + (s[1] - '0');
        if(num >= 10 && num <= 26) ++dp[1];
        if(s[0] != '0' && s[1] != '0') ++dp[1];
        if(n == 2) return dp[1];

        for(int i = 2; i < n; ++i)
        {
            if(s[i] != '0') dp[i] += dp[i-1];
            num = (s[i-1] - '0') * 10 + (s[i] - '0');
            if(num >= 10 && num <= 26) dp[i] += dp[i-2]; 
        }

        return dp[n-1];
    }
};
```

## 初始化优化

在上面的代码, 我们看到一些很繁琐的边界状况代码, 也就是循环前面的那些代码. 并且, 我们还可以看到, `dp[1]`的初始化代码和循环中的代码非常相似, 能不能把它们合起来吗? 

这就涉及到动态规划中的一个小技巧了, 那就是在`dp`中建立一个虚拟位置, 也就是说, 把`dp`加一个格子, 最前面的是虚拟位置, 其它的格子与之前的格子相互对应

![image-20250331125818482](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250331125818540.png)

虚拟位置中的值是有讲究的, 它要结合实际情况具体分析, 比如我们这里, 唯一能用到虚拟位置的位置其实就是原先的`dp[1]`, 现在的`dp[2]`, `dp[2]`什么时候回用到虚拟位置呢? 那不就是它和它和前面的字符组成了一个合法字段吗, 此时我们应该`+=`虚拟位置的值, 既然我们这里已经是合法字段了,  那就说明有一个方法, 那我应该`+= 1`, 而不应该是`+= 0`, 所以此处的虚拟位置值应该为一.        我们这题比较特别,   更多的情况是, 虚拟位置默认为0就行.

另外需要注意的是, 此时`dp`的`i`位置对应的是s`i-1`的位置, 不要把映射搞错了.

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n+1); dp[0] = 1;
        if(s[0] != '0') dp[1] = 1;
        if(n == 1) return dp[1];

        for(int i = 2; i <= n; ++i)
        {
            if(s[i-1] != '0') dp[i] += dp[i-1];
            int num = (s[i-2] - '0') * 10 + (s[i-1] - '0');
            if(num >= 10 && num <= 26) dp[i] += dp[i-2];
        }

        return dp[n];
    }
};
```

 # 完