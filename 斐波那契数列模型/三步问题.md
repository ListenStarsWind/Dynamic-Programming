# [三步问题](https://leetcode.cn/problems/three-steps-problem-lcci)

![image-20250330102405547](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250330102405616.png)

## 题目解析

有个小孩正在上楼梯, 该台阶有n阶台阶, (依我看, 可能是天梯), 小孩每次可以上一阶, 二阶, 或 三阶,  请你计算出小孩有多少种上楼梯的方式, 结果可能会很大, 为了避免溢出, 你需要对结果进行模 1000000007, 这里稍微提一嘴, 1000000007这个数在动态规划里是很常见的, 主要作用和这里一样, 都是为了避免状态溢出, 另外, C++支持科学计数法, 1000000007这个数可以表示为 1e9 + 7;

我们先举个例子, 当n为4的时候, 求有多少种可能.

首先我们把零定义为平地, 尽管题目中说n不可能为零, 但对于编程来说, 从零开始更加自然, 所以还是要从零开始.  我们可以认为在平地的方式有零种, 因为小孩本来就在平地, 这是一个事实, 所以可以认为是零种方式, 

如果要上一号台阶, 小孩可以直接从零号那里上一阶, 所以有一种可能, 一阶对应1,
如果要上二号台阶, 小孩可以直接从零号那里上二阶, 所以这是一套方式,有一种情况, 另外的一套方式是, 小孩先来到一号台阶, 再上一阶来到二号台阶, 有一种情况, 所以一共有两种可能, 二阶对应2,
如果要上三号台阶, 小孩可以直接从零号那里上三节, 这是一套方式, 有一种情况, 另外一套方式是, 小孩先来到一号台阶, 再上二阶来到三号台阶, 有一种情况, 还有一套方式是, 小孩先来到二号台阶, 再从二号那里上一阶, 有两种情况. 所以一共有四种可能, 三阶对应4
如果要上四号台阶, 有三套方式, 一是从一号台阶上三阶, 由于到达一号台阶的方式有一种, 所以该套方式有一种方式, 二是从二号台阶上二阶, 由于到达二号台阶的方式有两种, 所以这套方式一共有两种情况, 三是从三号台阶上一阶, 由于到达三号台阶的方式有四种, 所以该套方式一共有四种可能, 因此, 这三套方式合在一起就有七种可能, 四阶对应7,

对于五号台阶, 由于孩子每次可以上一阶, 二阶, 三阶, 所以孩子到达五号台阶前的状态可能位于四号台阶, 三号台阶, 二号台阶, 而到达四号台阶有七种方式, 到达三号台阶有四种方式, 到达二号台阶有两种方式, 所以合起来就是十三种方式.

## 算法原理

- 状态表示

  本问题可以抽象成一个数列, $T_1 = 1, T_2 = 2, T_3 = 4$, "且在n >= 4的条件下, $T_n = T_{n-1} + T_{n-2} + T_{n-3}$",  所以我们可以用一个整型数组来表示先前的历史状态, 其中`dp[n]`, 表示到达n号台阶的方式数

- 状态转移

  正如前文所言, "在n >= 4的条件下, $T_n = T_{n-1} + T_{n-2} + T_{n-3}$", 这就是本题的状态转移方程原型, 我们也可以推理一下,    对于n号台阶来说, 小孩到达n号台阶前的那个时间点, 他可能位于n-1号台阶, n-2号台阶, n-3号台阶, 而依据状态表示可知, "其中`dp[n]`, 表示到达n号台阶的方式数",  因此本题的状态转移方程就是`dp[n] = dp[n-1] + dp[n-2] + dp[n-3]`

- 初始化

  状态转移方程的使用前提是`n>=4`, 所以最开始需要把`dp[1], dp[2], dp[3]`进行初始化, 至于`dp[0]`, 因为没有实际意义, 所以可以不用考虑.

- 填表顺序

  很明显, 当`i > j`时, 必须先把`dp[j]`求出来, 才有可能把`dp[i]`求出来, 所以填报顺序是从左往右

- 返回值

  题目问我们, 到达n号台阶有多少种方式, 结合状态表示, 就是`dp[n]`

## 代码编写

```cpp
class Solution {
public:
    int waysToStep(int n) {

        // 边界状态
        if(n == 1) return 1;
        if(n == 2) return 2;
        if(n == 3) return 4;

        const int mod = 1e9 + 7;
        // 创建dp表
        unsigned int dp[n+1];  // 无符号防止和溢出
        // 初始化
        dp[1] = 1; dp[2] = 2; dp[3] = 4;
        // 状态转移
        for(int i = 4; i <= n; ++i)
        {
            dp[i] = dp[i-1] + dp[i-2]+dp[i-3];
            dp[i] %= mod;
        }

        // 返回
        return dp[n];
    }
};
```

## 空间优化

我们对于动态规划中空间优化的态度是, 在平时做题时, 如果能一眼看出来, 该怎么优化, 那你可以顺手优化一下, 如果不能一眼看出来, 那就别优化了, 而在笔试的时候, 因为动态规划一般都比较难, 所以能通过就不错了, 就不要去想空间优化了, 赶紧去做下一道题吧, 至于面试的时候, 你可以稍微谈谈思路.

```cpp
class Solution {
public:
    int waysToStep(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        if(n == 3) return 4;

        const int mod = 1e9 + 7;
        unsigned int a = 1, b = 2, c = 4, d = 0;
        for(int i = 4; i <= n; ++i)
        {
           d = a + b + c;
           d %= mod;

           a = b; b = c; c = d;
        }

        return d;
    }
};
```

# end

