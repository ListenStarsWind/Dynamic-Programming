# [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs)

![image-20250330130114137](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250330130114227.png)

## 题目解析

题目说的已经很清楚了, 下面, 我们就结合示例来模拟一遍.

示例一.  正如题目所说, 我们从下标为一的台阶开始爬, 支付15, 向上爬两个台阶到达楼顶顶部, 其中透露的一个关键信息就是楼顶的位置, 如果`n = cost.size()`, 那么n号位置才是楼顶的顶部, 对于示例一来说, `20`后面的那个位置才是楼顶, 而不是`20`本身是楼顶.    

本题我们将使用两种动态规划思路, 所以后续章节会分成ⅠⅡ两个版本

## Ⅰ

### 算法原理

- 状态表示

  题目让我们求的是到达n号位置的最小花费, 在加上它感觉是一种线性的形式, 所以我们可以先入为主的猜测:  `dp`表是一个一维数组, 其中`dp[n]`表示到达n号位置的最小花费

- 状态转移方程

  因为我们每次只能走一步或者两步, 所以从"在n号位置"这个状态往前推, 有两种可能的状态, 一是"在n-1号位置", 二是"在n-2号位置",    对于第一种情况来说, 它的花费为到达n-1号位置的最小花费再加上cost[n-1], 那到达n-1号位置的最小花费怎么得来呢? 我们发现, `dp[n]`就是表示达到n号位置的最小花费, 所以达到n-1号位置的最短花费, 不就是`dp[n-1]`吗? 状态表示和状态转移相呼应, 意味着我们的思路大概能行的通.所以对于第一种情况来说, 它的花费为`dp[n-1] + cost[n-1]`, 而对于第二种情况来说, 同理, 它的花费是`dp[n-2] + cost[n-2]`, 最后, 我们取一下其中最小的那个不就行了.    

  根据上面的分析, 就可以得到状态转移方程为`dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`

- 初始化

  依据状态转移方程, 我们可以知道, 如果想要求i位置的值, 前提条件是要知道前面两个位置的值, 因此, 我们的初始化操作, 就是把`dp[0], dp[1]`给填上. 由于题目说, 最开始可以从`0, 1`位置任选一个作为开始, 所以到达0, 1位置的花费为零.

- 填表顺序

  因为是用前面的位置推后面的位置., 所以很明显, 填表顺序是从左往右

- 返回值

  根据状态表示, 可知, 最后返回的就是`dp[n]`

### 代码编写

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int goal = cost.size();

        // 边界情况
        if(goal == 0 || goal == 1) return 0;

        // 建立dp表
        int dp[goal+1];
        
        // 初始化
        dp[0] = dp[1] = 0;

        // 状态转移
        for(int i = 2; i <= goal; ++i)
        {
            int planA = dp[i-2] + cost[i-2];
            int planB = dp[i-1] + cost[i-1];
            dp[i] = min(planA, planB);
        }

        return dp[goal];
    }
};
```

## Ⅱ

### 算法原理

- 状态表示

  刚刚的思路是以某个状态, 向前推, 我们这里, 则是以某个状态, 向后推.    所以我们可以将`dp[i]`定义为从n号位置开始, 到达楼顶的最小花费. 

- 状态转移方程

  状态转移方程描述的是相邻两个状态之间的转换方式, 因为我们是向后推, 所以从i开始, 你有两种选择, 第一种是往后走一步, 来到 i+1,   又或者, 往后走两步, 来到 i +2,    我们在这里回顾一下状态表示, `dp[i]`表示的是从n号位置开始, 到达终点的最小花费, 对于第一种情况, 它的花费就是cost[i]再加上从 i + 1开始达到终点的最小花费, 即`cost[i] + dp[i + 1]`, 对于第二种情况来说, 它的花费就是`cost[i] + dp[i + 2]`

- 初始化

  依据状态转移方程, 我们需要先知道后面的两个值, 才可以知道当前的值, 所以`dp[n-1] = cost[n-1], dp[n-2] = cost[n-2]`.

- 填表顺序

  依据状态转移方程, 可知, 应该是从右往左.

- 返回值

  由于我们最开始可以选择从0或者1号位置开始, 所以最终的返回值就是`min(dp[0], dp[1])`

### 代码编写

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        vector<int> dp(n);
        dp[n-1] = cost[n-1]; dp[n-2] = cost[n-2];
        for(int i = n-3; i >= 0; --i)
        {
            int planA = cost[i] + dp[i+2];
            int planB = cost[i] + dp[i+1];
            dp[i] = min(planA, planB);
        }

        return min(dp[0], dp[1]);
    }
};
```

# end



