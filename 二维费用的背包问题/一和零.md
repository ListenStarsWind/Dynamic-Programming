# [一和零](https://leetcode.cn/problems/ones-and-zeroes/)

![image-20250414193243892](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250414193244041.png)

## 题目解析

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例一**


>输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
>输出：4
>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
>其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

**示例二**


>输入：strs = ["10", "0", "1"], m = 1, n = 1
>输出：2
>解释：最大的子集是 {"0", "1"} ，所以答案是 2 。

这道题其实是一个01背包问题, 我们可以看到, 对于数组中的元素来说, 你可以选, 也可以不选, 选的话, 就放进背包, 让它们构成一个更长的字符串, 不选就不要放进背包, 稍有不同的是, 这次我们有两个限制条件, 一是背包中的字符串, 其中"0"的个数不能超过某个数字, "1"的个数也不能超过某个数字, 这就相当于背包它不仅有体积上的限制, 也有重量上的限制了.

## 算法原理

- **状态表示**

  既然, 背包的限制条件多了一个, 那我们的`dp`也增加一维, 我们定义, `dp[i][j][k]`表示, 在前`i`个字符串中选, 使得背包中字符串中的"零"个数不超过`j`, "一"个数不超过`k`, 在这三个条件下, 所能获得的最大的元素个数

- **状态转移**

  对于第`i`个元素, 我们有选或不选两种选择, 
  如果不选, 那就相当于在前`i-1`个元素中, "0"个数不超过`j`, "1"个数不超过`k`的最大元素个数, 就是`dp[i-1][j][k]`
  如果选, 我们设第`i`个元素中''0"的个数为`zeroes`, "1"的个数为`ones`, 那么, 这就相当于在前`i-1`个元素中, "0"个数不超过`j-zeroes`, "1"个数不超过`k-ones`, 这三个前提下, 所能获得的最大元素个数, 别忘了还要加上`i`这个"1", 因为它是必选的`dp[i-1][j-zeroes][k-ones] + 1`,

  最后我们选这两种情况最大的那个就行了, 当然, 要有合法性判断, 不要让`j-zeroes, k-ones`越界了

- **初始化**

  还是像往常一样, 我们在每个维度上都引入一些虚拟格, 所以它的虚拟位置实际上把正方体半包围了.
  ![image-20250414201514704](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250414201514782.png)

  就是从原点引出的三个面, 它们就是虚拟面, 但我们也不需要全部初始化, 就像之前那样, 我们只需要把`i = 0`的这一面初始化就行了, 就是最后面的那个面
  ![image-20250414201824085](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250414201824129.png)

  具体初始化成什么呢? 其实我们完全可以直接想, 当不选任何元素时, 那就相当于背包里放的是空字符串, 由于是空字符串, 所以它绝对满足"0", "1"的个数要求, 此时的元素个数就是零, 所以其实我们不需要初始化

- **填表顺序**

  我们用的都是上一个面的格子(`i`这个坐标的角度), 所以只要让`i`从小到大.

- **返回值**

  题目的探讨范围是整个数组, 所以返回值应该是`dp[len][m][n]`, (`len`表示数组的元素个数)

## 代码编写

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        vector<vector<vector<int>>> dp(len+1, vector<vector<int>>(m+1, vector<int>(n+1)));
        for(int i = 1; i <= len; ++i)
        {
            int zeros = 0, firsts = 0;
            for(auto c : strs[i-1])
            {
                if(c == '0') ++zeros;
                else ++firsts;
            }

            for(int j = 0; j <= m; ++j)
            {
                for(int k = 0; k <= n; ++k)
                {
                    dp[i][j][k] = dp[i-1][j][k];
                    if(j>=zeros && k >= firsts) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-zeros][k-firsts] + 1);
                }
            }
        }
        return dp[len][m][n];
    }
};      
```

## 空间优化

由于我们只会用到上一个面的状态, 所以可以只使用一个面, 也就是二维数组, 此时就相当于这个面既是当前面, 也是上一面, 需要注意的是, 根据状态表示, 我们会发现, 填当前格, 需要里面的状态, 或者说, 是需要上一面的状态, 所以遍历顺序必须从大到小, 遍历顺序必须改变 

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for(int i = 1; i <= len; ++i)
        {
            int zeroes = 0, ones = 0;
            for(auto c : strs[i-1])
            {
                if(c == '0') ++zeroes;
                else ++ones;
            }

            for(int j = m; j >= zeroes; --j)
            {
                for(int k = n; k >= ones; --k)
                    dp[j][k] = max(dp[j][k], dp[j-zeroes][k-ones] + 1);
            }
        }
        return dp[m][n];
    }
};      
```

# 完
