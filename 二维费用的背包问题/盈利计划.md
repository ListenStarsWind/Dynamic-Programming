# [盈利计划](https://leetcode.cn/problems/profitable-schemes/)

![image-20250415090146537](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250415090146729.png)

## 题目解析

集团里有 `n` 名员工，他们可以完成各种各样的工作创造利润。

第 `i` 种工作会产生 `profit[i]` 的利润，它要求 `group[i]` 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。

工作的任何至少产生 `minProfit` 利润的子集称为 **盈利计划** 。并且工作的成员总数最多为 `n` 。

有多少种计划可以选择？因为答案很大，所以 **返回结果模** `10^9 + 7` **的值**。

题目的需求是让我们求出有多少种"盈利计划", 什么是"盈利计划", "盈利计划"是一个事件, 它是若干个工作的集合, 集合里的每一个工作都需要若干个员工进行执行, 每完成一个工作便能获得一定数目的利润, 但我们的员工数量是有限的, 集合里工作的总人数不能超过这个个数.

**示例一**


>输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
>输出：2
>解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
>总的来说，有两种计划。

有两个盈利计划,
第一个, 工作零和工作一都去做, 需要的总人数是4, 没有超过公司总人数5, 达到的利润是5, 大于盈利计划最低要求, 3.
第二个, 只进行工作一, 需要的人数是2, 没有超过总人数5, 达到的利润是3, 正好是盈利计划的最低值

**示例二**


>输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
>输出：7
>解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
>有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。

即使是所有工作加起来, 其需要的总人数仍旧没有超过公司的总人数, 并且, 每个工作都超过了盈利计划的最低值, 所以可以随意搭配组合.

整道题可以被简化为一个01二维背包问题. 现在我们有一些工作,每个工作可以选或者不选, 选中工作构成的集合有两点要求需要被满足, 一是总人数不得大于公司总人数, 而是总利润不得小于"盈利计划"最低利润.

## 算法原理

- **状态表示**

  定义`dp[i][j][k]`表示, 在前`i`个工作中选, 总人数不超过`j`, 总利润至少为`k`, 一共有多少种选法

- **状态转移**

  对于第`i`个任务, 我可以选, 也可以不选
  不选时, 那就相当于在前`i-1`个工作中找总人数不超过`j`, 总利润至少为`k`, 一共有多少种选法.
  选择时, 那就相当于在前`i-1`个工作中找总人数不超过`j-group[i]`, 总利润至少为`k-profit[i]`, 一共有多少种选法
  需要特别注意的是, `j-group[i]`是不能为负数的, 它为负数意味着仅仅是这一项工作, 就已经超出了公司总人数, 所以这个工作完全不能碰,   而`k-profit[i]`可以为负数, 它为负数意味着这个工作利润太大了, 仅靠它一个, 就可以超额完成当前"盈利计划"`k`的最低指标, 但很明显, 我们的矩阵体里不会有负数下标, 所以我们要想个办法, 把它引导到合法的位置上, 既然仅靠这一个任务就可以完成"盈利计划", 那么, 前面的工作做不做都无所谓, 什么叫做不做都无所谓, 那就是利润为零, 只要前面的工作利润和大于零就行.所以我们要用`max(0, k-profit[i])`, 

  综上`dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-group[i]][max(0, k-profit[i])]`, 另外, 别忘了还有个`mod = 1e9+7`

- **初始化**

  还是和之前一样, 我们只需要初始化`i`为`0`的, 最后面的那个面, 并且, 由于一个工作都不做, 所以肯定无法满足"利润至少为正数"的要求, 因此, 对于`k`为正数的情况, 选法都是0, 我们不必初始化, 而对于`dp[0][j][0]`来说, 一个任务也不选, 利润至少为零, 这种情况在任意人数下都是可以达到的, 所以它们都有一种选法.

- **填表顺序**

  填当前面`i`需要前面的面`i-1`, 所以填表顺序只要是从后往前就行

- **返回值**

  返回最后一个格子的值`dp[size][n][minProfit]`

## 代码编写

```cpp
class Solution {
    const int mod = 1e9+7;
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        int size = group.size();
        vector<vector<vector<int>>> dp(size+1, vector<vector<int>>(n+1, vector<int>(minProfit+1)));
        for(int j = 0; j <= n; ++j) dp[0][j][0] = 1;
        for(int i = 1; i <= size; ++i)
        {
            for(int j = 0; j <= n; ++j)
            {
                for(int k = 0; k <= minProfit; ++k)
                {
                    dp[i][j][k] = dp[i-1][j][k];
                    if(j >= group[i-1]) dp[i][j][k] += dp[i-1][j-group[i-1]][max(0, k-profit[i-1])];
                    dp[i][j][k] %= mod;
                }
            }
        }
        return dp[size][n][minProfit];
    }
};
```

## 空间优化

此时, 面既是当前面, 也是上一面, 由于对于每个格子来说, 需要上一面的状态, 所以上一面要在后面被覆盖. 另外, 注意`k`是大于等于0的, 因为它可以为负.

```cpp
class Solution {
    const int mod = 1e9+7;
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        int size = group.size();
        vector<vector<int>> dp(n+1, vector<int>(minProfit+1));
        for(int j = 0; j <= n; ++j) dp[j][0] = 1;
        for(int i = 1; i <= size; ++i)
        {
            for(int j = n; j >= group[i-1]; --j)
            {
                for(int k = minProfit; k >= 0; --k)
                {
                    dp[j][k] += dp[j-group[i-1]][max(0, k-profit[i-1])];
                    dp[j][k] %= mod;
                }
            }       
        }
        return dp[n][minProfit];
    }
};
```

# 完
