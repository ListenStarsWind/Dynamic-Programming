# [编辑距离](https://leetcode.cn/problems/edit-distance/)

![image-20250420103557687](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250420103557774.png)

## 题目解析

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符

  比如, 对于字符串`"ca"`和`"cat"`来说, 你可以在`"ca"`后面加上字符`t`, 使它们都变为`"cat"`, 从而变得相等

- 删除一个字符

  还是拿`"ca", "cat"`为例, 你可以把`"cat"`中的`'t'`删除, 使它们都变为`"ca"`, 从而变得相同

- 替换一个字符

  对于字符串`"cae"`和`"cat"`来说, 你可以把`"cae"`中的`'e'`替换为`'t'`, 从而让它们都变成`"cat"`
  又或者, 你可以把`"cat"`中的`'t'`替换成`'e'`, 从而让它们都变成`"cae"`

**示例一**


>输入：word1 = "horse", word2 = "ros"
>输出：3
>解释：
>horse -> rorse (将 'h' 替换为 'r')
>rorse -> rose (删除 'r')
>rose -> ros (删除 'e')

**示例二**

>输入：word1 = "intention", word2 = "execution"
>输出：5
>解释：
>intention -> inention (删除 't')
>inention -> enention (将 'i' 替换为 'e')
>enention -> exention (将 'n' 替换为 'x')
>exention -> exection (将 'n' 替换为 'c')
>exection -> execution (插入 'u')

## 算法原理

- **预处理**

  题目中涉及到三种操作方式, 分别是, "插入一个字符", "删除一个字符", "替换一个字符", 这些操作与`word1, word2`这两个字符串相结合, 就能出现六种可能, 这实在是太多了, 因此我们需要预处理, 对场景的复杂程度和规模进行化简.

  正如我们在题目解析环节所说的那样, "插入一个字符"和"删除一个字符", 就最后的结果(使两个字符串相同)其实是等效的,  比如, 同样是为了把`"ca"`和`"cat"`这两个字符串变得相同, 你可以对`"ca"`进行插入操作, 使之变为`"cat"`, 这样相同的字符串就是`"cat"`亦或者, 你可以把`"cat"`中的`'t'`删除, 这样相同的字符串就是`"ca"`, 尽管这两种方法最后得到的"相同的字符串"是不同的, 但就我们的需求"使两个字符串变得相同"而言却是等效的,  这样的话, 我们就可以将"对`word1`删除一个字符"视为"对`word2`插入一个字符", "对`word2`删除一个字符"视为"对`word1`插入一个字符"

  对于"替换一个字符"来说, 在题目解析环节, 其实我们就暗含着可以将"`word1`替换一个字符", 视为对"`word2`替换一个字符", 比如, 同样是对于`"cae", "cat"`来说, 既可以把`"cat"`中的`'t'`替换为`'e'`, 也可以将`"cae"`中的`'e'`替换成`'t'`, 最终的结果都是一样的.

  关于"最后的结果都是一样的", 其实还有一个没有说的地方, 那就是它们都是建立在前缀字符串相同的基础上的, 比如, 把`"ca"`加上`'t'`变成`"cat"`, 和把`"cat"`删除`'t'`得到`"ca"`, 其操作步数都是1, 但这是建立在相同的基础上的, 那就是`"cat"`中的`"ca"`要等于`"ca"`中的`"ca"`, 因为"<u>ca</u>t"和"<u>ca</u>"的前缀都是相同的, 所以无论是删除还是插入, 结果都是等效的,   同样的, 对于替换来说, "<u>ca</u>t"和"<u>ca</u>e"的前缀字符串也是要相等的

  那么我们如何保持"前缀相等"呢? 其实很简单, 我们本来的需求是求两个字符串变得相同的最小操作步长, 现在的需求是求让它们前缀相同的最小操作步长, 这不还是让两个字符串相同吗? 所以我们就可以通过发现本题中的重复性子问题得出, 本题可以使用动态规划

- **状态表示**

  我们的重复性子问题是, "让两个字符串相同的最少操作数是多少", 因此我们可以定义`dp[i][j]`表示, 以`word1`的`[0,i]`区间构成的字符串, 和 以`word2`的`[0,j]`区间构成的字符串, 让它们变得相同, 所需要的最小操作次数

- **状态转移**

  对于`[0,i]`和`[0,j]`的字符串来说, 我们有三种方案, 让它们变得相同

  - 方案一

    先把`word1` `[0,i]`子串和`word2` `[0,j-1]`字符串变得相同, 在此基础上, 在`word1`的`[0,i]`后面插入一个`word2[j]`

    有`dp[i][j] = dp[i][j-1] + 1`

  - 方案二

    先把`word1` `[0,i-1]`字符串和`word2` `[0,j]`字符串变得相同, 在此基础上, 在`word2`的`[0,j]`后面插入一个`word1[i]`

    有`dp[i][j] = dp[i-1][j] + 1`

  - 方案三

    先把`word1[0, i-1]`和`word2[0, j-1]`字符串变得相同, 在此基础上, 如果`word1[i] == word2[j]`那就不需要进行替换了, 如果不相等, 那么要么把`word1[i]`替换成`word2[j]`, 要么把`word2[j]`替换成`word1[i]`

    有`dp[i][j] = word1[i] == word2[j] ? dp[i-1][j-1] : dp[i-1][j-1] + 1`

  最后选择最小的那个

- **初始化**

  在状态表示环节我们发现, 可能会用到左边的格子`dp[i][j-1]`和上边的格子`dp[i-1][j]`, 又或者左上角的格子`dp[i-1][j-1]`, 为此我们可以引入虚拟位置, 并使用空字符的概念去赋予虚拟位置实际的意义, 这样的话, 对于虚拟位置来说, 其实际的意义就是, 当两个字符串中至少有一个空字符串时, 使他们变得相同的最小操作步数, 对于这种情况, 比如是`"cat", ""`, 要么把`"cat"`变成空的, 要么把空字符串变成`"cat"`, 总之就是那个非空字符串的长度.  另外, 由于引入了虚拟位置, 要注意下标的映射关系.

- **填表顺序**

  从左往右, 从上往下

- **返回值**

  题目要的是这两个整的字符串变得相同的最小操作步数, 所以就是`dp[m][n]`

## 代码编写

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for(int i = 1; i <= m; ++i) dp[i][0] = i;
        for(int j = 1; j <= n; ++j) dp[0][j] = j;
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1;
                dp[i][j] = min(dp[i][j], word1[i-1] == word2[j-1] ? dp[i-1][j-1] : dp[i-1][j-1] + 1);
            }
        }
        return dp[m][n];
    }
}; 
```

# 完
