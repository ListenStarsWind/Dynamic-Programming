# [K 个逆序对数组](https://leetcode.cn/problems/k-inverse-pairs-array/)

![image-20250531195841664](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250531195841838.png)

## 算法原理

具体的就不说了, 看代码注释, 这里只说一个小细节, 那就是要小心模运算, 如果模运算出了负数, 是要补齐的.

## 代码编写

```cpp
class Solution {
    /*
        定义memo[i][j]表示选择[1-i]这i个数所组成的长度为i,
       逆序对个数为j的排列种数 对于i位置长度的最后一个元素, 可以选择, 1 到
       i这i个数中的一个进行填补, 我们把这个 数记为k, 当选择k时,
       前面的i-1部分区间就是由1,2,3, ...., k-1, k+1, k+2,..., i进行填充
        我们易知, 对于k来说, 由于k+1, k+2, k+3, i这些数都位于k的前面,
       所以可以贡献i-k个逆序对 此时, 若要找出j个逆序对, 只需要在i-1,
       即k前面的这一部分, 找出j-(i-k)个逆序对即可 下面是关键,
       将相邻状态建立联系, 把问题转化成同类型子问题的关键
        由于逆序关注的是数字之间的相对大小关系, 所以我们可以把前面的 k + 1, 到 i
       这一部分都进行减一操作 这一部分同时减去一,
       所以他们本身的相对大小不会发生改变, 并且, 由于是k-1再到k+1的,
       所以即使k+1到i 这一部分同时减一也不会影响它们与前面那部分数字的关系,
       所以, 此时在 "在i-1, 即k前面的这一部分,
       找出j-(i-k)个逆序对"这个子问题已经被转化成了在1到i-1这i-1个数中, 寻找
        j-(i-k)个逆序对的种类数
        此时就有dp[i][j] =            dp[i-1][j-i+1] + dp[i-1][j-i+2] +
       dp[i-1][j-i+3] + .... + dp[i-1][j-1] + dp[i-1][j]
        但这种计算方式的时间复杂度过高, 所以我们纯粹从数学的角度来看,
       对于dp[i][j-1], 我们可以有 dp[i][j-1] = dp[i-1][j-i] +  dp[i-1][j-i+1] +
       dp[i-1][j-i+2] + ...............       + dp[i-1][j-2] + dp[i-1][j-1]
        这样的话, 就有dp[i][j] = dp[i][j-1] - dp[i-1][j-i] + dp[i-1][j]

        注意, 当y坐标小于0时, 因为个数不会为负, 所以种类数就是零
        对于[0][0]来说, 零个数只有一种搭配方式, 并且这种搭配方式就是零个逆序对
       [0][0] = 1; 对于[0]的其他列来说, 都不可能, 返回零
    */

    /*
        10^6次方数量级并不大, 直接使用静态数组
    */

    int dp[1001][1001] = {0};

    const int MOD = 1e9 + 7;

public:
    int kInversePairs(int n, int k) {

        dp[0][0] = 1;
        for (int i = 1; i <= n; ++i) 
        {
            for (int j = 0; j <= k; ++j) 
            {
                long long x = 0, y = 0;
                if(j-1 >= 0) x = dp[i][j-1];
                if(j-i >= 0) y = dp[i-1][j-i];

                dp[i][j] = (x - y + dp[i-1][j]) % MOD; 
                if(dp[i][j] < 0) dp[i][j] += MOD;
            }
        }

        return dp[n][k];
    }
};
```

# 完

