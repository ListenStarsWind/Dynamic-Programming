# [学生出勤记录 II](https://leetcode.cn/problems/student-attendance-record-ii/)

![image-20250527202812989](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250527202813073.png)

## 算法原理

略, 看注释去, 也不空间优化, 优化之后就没人能看懂了

## 代码编写

```cpp
class Solution {

    const int MOD = 1e9 +7;
public:
    int checkRecord(int n) {
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(3)));

        // 当n == 0 时, 尽管你一天都没来上学, 但考虑你并没有犯错, 所以仍旧能得奖(谢谢参与)
        dp[0][0][0] = 1;
        // 对于n == 0的其它五个格子来说, 它们是没有发生可能的, 所以没有对应的获奖机会.
        for(int i = 1; i <= n; ++i)
        {
            // dp[i][0][0]
            // 第二个坐标表示当前总的缺勤次数, 既然在今天, 我都没有缺勤过一次, 那么之前也自然没有缺勤
            // 第三个坐标表示包括今天在内的连续迟到天数, 我今天没有迟到, 那我前天就有三种可能, 也许

            // 之前我已经连续迟到了两天, 然后发现不能再迟了, 所以今天特意起得早
            dp[i][0][0] += dp[i-1][0][2];
            dp[i][0][0] %= MOD;

            // 之前我已经连续迟到了一天, 可能是今天吸取了昨天迟到的经验, 所以今天没有再迟到
            dp[i][0][0] += dp[i-1][0][1];
            dp[i][0][0] %= MOD;

            // 昨天你也没有迟到, 要么是好学生, 要么是像第一种可能那样, 昨天恰好就是记得特别早的那天
            dp[i][0][0] += dp[i-1][0][0];
            dp[i][0][0] %= MOD;
            
            // dp[i][0][1]
            // 包括今天在内, 我没有缺过一次勤, 但连续迟到了一天

            // 因为迟到是连续的, 所以今天已经连续迟到了一天, 那为了连续, 今天必须是迟到的, 所以昨天一定没有迟到
            dp[i][0][1] += dp[i-1][0][0];
            dp[i][0][1] %= MOD;


            // dp[i][0][2]
            // 截止目前, 我没有缺过一次勤, 但我已经迟到了两天, 连续
            dp[i][0][2] += dp[i-1][0][1];
            dp[i][0][2] %= MOD;

            // dp[i][1][0]
            // 截止目前, 我缺过一次勤, 连续迟到天数为0
            // 就缺勤的角度, 来说, 这一次缺勤可能是今天缺勤了, 也可能是之前, 也就是昨天的时候, 已经有这条缺勤记录了
            dp[i][1][0] += dp[i-1][0][0];
            dp[i][1][0] %= MOD;
            dp[i][1][0] += dp[i-1][0][1];
            dp[i][1][0] %= MOD;
            dp[i][1][0] += dp[i-1][0][2];
            dp[i][1][0] %= MOD;
            dp[i][1][0] += dp[i-1][1][0];
            dp[i][1][0] %= MOD;
            dp[i][1][0] += dp[i-1][1][1];
            dp[i][1][0] %= MOD;
            dp[i][1][0] += dp[i-1][1][2];
            dp[i][1][0] %= MOD;


            // dp[i][1][1]
            // 由于迟到必须是连续的, 所以这意味着我今天迟到了, 因此, 之前的缺勤记录一定是之前造成的
            dp[i][1][1] += dp[i-1][1][0];
            dp[i][1][1] %= MOD;

            // dp[i][1][2]
            // 由于迟到是连续的, 所以昨天一定迟到了, 今天也是
            dp[i][1][2] += dp[i-1][1][1];
            dp[i][1][2] %= MOD;
        }

        int res = 0;
        for(int i = 0; i < 2; ++i)
        {
            for(int j = 0; j < 3; ++j)
            {
                res = (res + dp[n][i][j]) % MOD;
            }
        }

        return res;
    }
};
```

# 完

