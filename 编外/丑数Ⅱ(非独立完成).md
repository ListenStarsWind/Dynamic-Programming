# [丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

![image-20250505165832657](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250505165832703.png)

## 算法原理

我们定义 `dp[i]` 表示第 `i` 个丑数。根据题意，丑数只能由质因数 2、3、5 构成，因此我们维护三个指针 `p2`、`p3`、`p5`，分别表示当前能与 2、3、5 相乘、生成新丑数的最小下标。

由于 `dp[i]` 要表示当前还未出现的最小丑数，我们需要从每种质因数的“乘法链”中，选出下一个最小的候选丑数。考虑到 `dp` 是严格递增的，只需使用当前指针所指的最小下标，即 `dp[p2] * 2`、`dp[p3] * 3`、`dp[p5] * 5`，分别作为下一轮的候选。

每一轮，我们从这三个候选中选出最小的一个作为 `dp[i]`，即第 `i` 个丑数。如果多个候选值相等，为了避免重复，对应的指针都要前移一位，表示下次尝试与后续丑数组合。

初始时，`dp[1] = 1`，表示第一个丑数是 1。此时三个指针都指向下标 1，分别对应候选值：

- `dp[p2] * 2`
- `dp[p3] * 3`
- `dp[p5] * 5`

它们正是各自乘法链中当前最小的候选丑数。

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n+1);
        dp[1] = 1;
        int p2, p3, p5;
        p2 = p3 = p5 = 1;
        for(int i = 2; i <= n; ++i)
        {
            int a = dp[p2] * 2;
            int b = dp[p3] * 3;
            int c = dp[p5] * 5;
            dp[i] = min(a, min(b, c));
            if(dp[i] == a) ++p2;
            if(dp[i] == b) ++p3;
            if(dp[i] == c) ++p5;
        }
        return dp[n];
    }
};
```

解法二

我们可以感性的体会到, 后面的丑数都是前面丑数乘上2, 3, 5得到的, 所以我们可以从当前的,最小丑数, 当然, 不能重复, 乘上2, 3, 5, 然后把结果都放回数据结构, 为了快速找到当前最小的丑数, 我们使用最小堆来存储丑数们

每轮, 我们从丑数中取出栈顶, 为了避免重复, 要是`pop`那种栈顶取出, 然后根据栈顶, 分别乘上2, 3, 5 就得到了基于该栈顶的丑数, 比如, 最开始堆只有1, 然后进入循环, 取出第一个大的丑数, 1, 得到, 2, 3, 5, 放回堆, 之后, 取出2, 得到, 4, 6, 10, 放入堆中, 接着进入第三轮, 取出第三大的丑数, 3, 得到, 6, 9, 15, 我们看到, 这里出现了重复, 所以我们还要准备一个哈希进行去重..

第`n`轮取出的堆顶, 就是第`n`大的丑数, 所以循环`n`轮. 

# 完