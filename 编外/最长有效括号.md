# [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

![image-20250416085553329](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250416085553689.png)

## 题目解析

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例一**


>输入：s = "(()"
>输出：2
>解释：最长有效括号子串是 "()"

**示例二**


>输入：s = ")()())"
>输出：4
>解释：最长有效括号子串是 "()()"

**示例三**


>输入：s = ""
>输出：0

## 算法原理

- **状态表示**

  定义`dp[i]`表示, 以`i`为结尾的有效子串的最长长度.

- **状态转移**

  对于第`i`个位置来说, 它无非两种可能, 要么是`'('`, 要么是`')'`

  如果一个子串以`'('`为结尾, 那就意味着以该位置为结尾的子串没有有效的, 所以`dp[i] = 0`

  如果一个子串以`')'`为结尾, 那我们就需要在前面找与之配对的`'('`
  如果前一个字符, 即`i-1`就是`'('`, 那这就巧了, 此时`i-1, i`正好可以拼成一个里面没内容的括号, 此时的有效长度就是以`i-2`为结尾的最长长度再加上最后的这一对括号, 也就是`dp[i] = dp[i-2] + 2`

  如果前一个字符还是`')'`, 那我们就只能再往前面找, 由于`i-1`的这个`')'`可能与前面的某些字符配对, 形成有效的子串, 所以我们必须略过它们, 来到`i-dp[i-1]-1`, 这个位置, 如果这个位置还是`')'`, 那我们就不需要再往前找了, 因为即使前面找到了`'('`, 也会因为中间夹的这个`')'`而变成无效的,此时, `dp[i] = 0`

  如果`i-dp[i-1]-1`这个位置是`'('`, 那就能成功配对, 此时以`i`为结尾的有效子串由三部分构成, 一是`i-dp[i-1]-1`前面的位置, 也就是`i-dp[i-1]-2`可能也是某个有效子串的结尾, 即使它不是, `0`加上也不会有影响, 第二是`i-dp[i-1]-1`和`i`中间包含的那些有效子串, 第三部分就是`i-dp[i-1], i`这一对括号, 所以就是`dp[i] = dp[i-dp[i-1]-2] + dp[i-1] + 2`

- **初始化**

  首先我们可以看到在状态转移中, 有很多情况最后的`dp[i]`都是零, 所以我们在对`dp`进行初始化时, 就可以直接使用默认的`0`进行初始化, 另外, 我们看到的是, 在状态转移中有很多危险操作, 非常容易越界, 什么`dp[i-2]`, `s[i-dp[i-1]-1]`, `dp[i-dp[i-1]-2]`, 所以我们可以为`dp`的最前面引入一个虚拟位置, 同时也可以在`s`的前面引入一个空格, 这样做的好处是, 对`dp`表的访问都是建立在对`s`访问出合法字符的情况下进行的, 如果`s`访问出了一个空格, 那就不会进行`dp`访问, 就不会略过中间的有效子串来到有效子串的前一位, 比如说, 我们害怕去找`dp[0]`的前一位, 但这可能吗? 不可能, 因为去找`dp[0]`前一位的前提是`s[0] == '('`, 但我们加的空格确保这不会发生, 再比如, 如果`i`是第一个实体字符, 而且就是`')'`, 那它前面的可是空格, 进入不了分支, 两个分支都进不去

- **填表顺序**

  从左往右

- **返回值**

  `dp[n]`

## 代码编写

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size(), result = 0;
        vector<int> dp(n+1); s = " " + s;
        for(int i = 1; i <= n; ++i)
        {
            if(s[i] == ')')
            {
                if(s[i-1] == '(')
                    dp[i] = dp[i-2] +2;
                else
                {
                    if(s[i-dp[i-1]-1] == '(')
                        dp[i] = dp[i-dp[i-1]-2] + dp[i-1] + 2;
                }
                result = max(result, dp[i]);
            }
        }
        return result;
    }
};
```

# 完



