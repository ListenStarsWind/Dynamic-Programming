# [目标和](https://leetcode.cn/problems/target-sum/)

![image-20250413111547660](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250413111547733.png)

## 题目解析

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 **示例一**


>输入：nums = [1,1,1,1,1], target = 3
>输出：5
>解释：一共有 5 种方法让最终目标和为 3 。
>-1 + 1 + 1 + 1 + 1 = 3
>+1 - 1 + 1 + 1 + 1 = 3
>+1 + 1 - 1 + 1 + 1 = 3
>+1 + 1 + 1 - 1 + 1 = 3
>+1 + 1 + 1 + 1 - 1 = 3

一个有五个一, 目标却是三, 所以只要有四个一和一个负一就行了, 负一有五个位子可供选择, 所以是五

**示例二**


>输入：nums = [1], target = 1
>输出：1

## 算法原理

这道题不能直接使用动规来进行解题. 我们要使用一点小技巧, 把本题转换成更简单的问题, 实际上, 这个转换过程是本题中最难的一点, 转换完成就可以随手做了.

题目告诉我们可以在数字前面放上"+"(正号)或者"-"(负号), 所以我们可以把数组中的元素分为两类, 第一类是使用正号的那些, 第二类是使用负号的那些, 设, 这两类数的绝对值和分别是`a`, `b`.
![image-20250413113448786](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250413113448845.png)

题目说, 最后这两类数的元素和是`target`, 所以就有`a-b = target`, `a,b`是未知的, 我们如果要进行求解还需要一个方程, `a,b`还有什么关系可以被我们直接得出呢? 那就是它们的和, 由于`a,b`都是元素绝对值的和, 而原数组是非负数(零很关键, 等会儿我们会在初始化说这个0), 所以其实也是元素绝对值, 因此原始数组的和就是`a,b`的和, 这样就有`a+b = sum`, 这样就可以构成一个方程组, 这样就能求解出`a = (target + sum) / 2`

所以我们的问题就转换成了, 在数组中选择一些数, 使得它们的和是`a`, 问有多少种选法

- **状态表示**

  对于数组中的每个元素, 我们都有选或者不选这两种操作, 所以我们可以定义`dp[i][j]`为前`i`个元素选, 总和正好等于`j`, 问有多少种选法

- **状态表示**

  对于第`i`个元素, 我们有选或者不选这两种操作. 如果我们不选, 那就相当于在前`i-1`个元素里面选, 总和恰好是`j`, 即`dp[i-1][j]`,          如果我们选, 那就相当于在前`i-1`个元素里面选, 总和恰好是`j-nums[i]`, 即`dp[i-1][j-nums[i]]`, 另外需要注意, `j-nums[i]`可能越界, 需要进行判断才可以统计, 最后因为求的是"一共", 所以这两种情况, 能加的都要加上去

- **初始化**

  首先, 我们要引入虚拟位置, 先看第一行, 第一行除了`[0][0]`之外, 都是在不选择元素的前提下凑出一个正数, 所以选不出来, 都是0, 至于`[0][0]`, 因为目标是0, 所以不选就行了, 选法是1,                          接下来就要看第一列了, 第一列和之前的01背包不太一样, 或许你认为, 要凑的数是零, 所以只有一个元素都不选这一种方案, 所以第一列应该全是一, 但是, 并不是这样, 因为可能数组中可能存在元素0, 此时就不止这一种选法, 你还可以选零, 这怎么办呢? 其实, 我们可以不初始化, 直接把它放到填表里, 也就是把填表的初始下标由1变成0开始, 

  如果`nums[i]`真的为零, 那`dp[i-1][j-nums[i]]`也不会越界, 也会把选`i`这种情况考虑进去, 所以就不用我们亲自初始化

- **填表顺序**

  从上往下

- **返回值**

  `a`可能存在一些特殊情况, 比如为小数, 或者为负数, 对于这种情况, 那就选不出来, 所以直接返回零, 这相当于边界处理, 如果`a`正常, 那么题目问我们的事整个数组, 所以用最大区间就行, 也就是最右下角的格子

## 代码编写

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = target;
        for(auto e: nums) sum += e;
        if(sum < 0 || sum % 2 == 1) return 0;
        int n = nums.size(), V = sum / 2;
        vector<vector<int>> dp(n+1, vector<int>(V+1));
        dp[0][0] = 1;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 0; j <= V; ++j)
            {
                dp[i][j] = dp[i-1][j];
                if(j >= nums[i-1]) dp[i][j] += dp[i-1][j-nums[i-1]];
            }
        }
        return dp[n][V];
    }
};
```

## 优化

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = target;
        for(auto e: nums) sum += e;
        if(sum < 0 || sum % 2 == 1) return 0;
        int n = nums.size(), V = sum / 2;
        vector<int> dp(V+1); dp[0] = 1;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = V; j >= nums[i-1]; --j) 
                dp[j] += dp[j-nums[i-1]];
        }
        return dp[V];
    }
};
```

# 完
