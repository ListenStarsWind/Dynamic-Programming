# [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

![image-20250413093017752](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250413093017821.png)

## 题目解析

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

意思就是准备两块地方, 把数组中的一部分元素放在第一块地方, 另一部分元素放在第二块地方, 让这两块地方的元素和相等, 并且最后原数组中没有元素, 就是把数组中的元素全部用上. 

**示例一**


>输入：nums = [1,5,11,5]
>输出：true
>解释：数组可以分割成 [1, 5, 5] 和 [11] 。

**示例二**


>输入：nums = [1,2,3,5]
>输出：false
>解释：数组不能分割成两个元素和相等的子集。

## 算法原理

这道题不好直接做, 所以我们要换个角度来看问题. 我们知道, 我们要把数组分成两个子集, 并使得两个子集的元素和相等, 这样的话, 如果将整个数组的元素和设为`sum`, 那么两个子集的元素和不就是`sum/2`吗? 并且我们其实只要一块地方就行了, 此时问题就变成了, 从数组里挑选出一些元素, 放到这块地方, 让这块地方的元素和等于`sum/2`

这样, 对于数组中的每个元素我都有选或不选两种情况, 这其实就是01背包问题.  我们可以把数组中的元素视为一些物品, 可以选或者不选, 现在有一个容积为`sum/2`的背包, 请判断这个背包能不能填满

- **状态表示**

  这道题比普通的01背包更简单, 因为没有价值, 只要看背包能不能被填满就行了, 我们可以模仿01背包的思路, 我们定义`dp[i][j]`表示, 从前`i`个数中选, 所有的选法中, 能否凑成`j`这个数, 如果能, 那值就是`true`, 不能, 就是`flase`

- **状态转移**

  当我们走到第`i`个位置的时候, 对它有两种操作, 一是选, 二是不选, 当不选`i`时, 就相当于在前`i-1`个数中选, 并且要凑成`j`, 即`dp[i][j] = dp[i-1][j]`, 当选择`i`时, 相当于我们还要在前`i-1`个数里面选择一些数, 把它们凑成`j-nums[i]` , 即`dp[i][j] = dp[i-1][j-nums[i]]`, 不过, `j-nums[i]`不一定存在, 所以第二种操作有一个前提条件, 那就是`j-nums[i] >= 0`

- **初始化**

  我们还是引入虚拟位置, 为此一方面要注意下标映射关系, 另一方面, 要为虚拟位置填值, 对于第一列来说, 表示背包容积为零的情况, 此时只要什么都不选, 就能选出来了, 所以第一列的值都是`true`, 对于第一行的剩余内容, 由于它表示0个数前, 所以填不满背包, 因此都初始化为`false`, 

- **填表顺序**

  填一个格子时, 可能用到它上一行的内容, 所以填表顺序是从上往下

- **返回值**

  题目的研究对象是整个数组, 所以就是在前`n`个数字选, 即`dp[n][V]`, 另外, 如果`sum/2`是计数, 那一定分不成两份, 所以应作为边界条件进行特殊处理

## 代码编写

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto e : nums) sum += e;
        if(sum % 2 == 1) return false;
        int n = nums.size(), V = sum / 2;
        vector<vector<bool>> dp(n+1, vector<bool>(V+1));
        for(int i = 0; i <= n; ++i) dp[i][0] = true;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= V; ++j)
            {
                dp[i][j] = dp[i-1][j];
                if(j - nums[i-1] >= 0)
                    dp[i][j] = dp[i][j] || dp[i-1][j-nums[i-1]];
            }
        }
        return dp[n][V];
    }
};
```

## 优化

我们使用滚动数组的思想对其进行优化, 此时, 整个二维数组将被简化为一维, 也就是只要把行号去掉就行了, 另外, 此时这一维数组相当于既扮演上一行的角色, 也扮演者当前行的角色, 由于填某个格子需要用到前面的格子, 所以填表顺序必须是从右往左, 另外, 我们可以把`j >= nums[i-1]`放在循环条件里, 因为对于内层循环来说, `nums[i-1]`是确定的, 而`j`是不断变小的, 所以只要出现一次`j`小于`nums[i-1]`, 那就说明后面还会继续小于, 所以就可以直接结束

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto e : nums) sum += e;
        if(sum % 2 == 1) return false;
        int n = nums.size(), V = sum / 2;
        vector<bool> dp(V+1); dp[0] = true;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = V; j >= nums[i-1]; --j)
                dp[j] = dp[j] || dp[j-nums[i-1]];
        }
        return dp[V];
    }
};
```

# 完
