# [最后一块石头的重量II](https://leetcode.cn/problems/last-stone-weight-ii)

![image-20250413131721033](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250413131721099.png)

## 题目解析

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例一**


>输入：stones = [2,7,4,1,8,1]
>输出：1
>解释：
>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

组合1 和 1, 得到0, 所以数组转化成[2,7,4,8],
组合2 和 7, 得到5, 所以数组转化为[5,4,8],
组合4 和 8, 得到4, 所以数组转化为[5,4],
组合5 和 4, 得到1, 所以数组转化为[1], 这就是最优值.

组合1 和 1, 得到0, 所以数组转化成[2,7,4,8],
组合2 和 4, 得到2, 所以数组转化成[2,7,8],
组合7 和 8, 得到1, 所以数组转化成[2,1],
组合2 和 1, 得到1, 所以数组转化成[1], 这就是最优值.

**示例二**


>输入：stones = [31,26,33,21,40]
>输出：5

组合31 和 33, 得到2, 所以数组转化成[2,26,21,40]
组合21 和 40, 得到19, 所以数组转化成[2,26,19]
组合26 和 19, 得到7, 所以数组转化成[2,7]
组合2 和 7, 得到5, 所以数组转化成[5], 这就是最优值.

## 算法原理

这道题不能直接用动态规划解, 需要先转化为一个更简单的问题, 转化的具体过程, 是本题中最难的点.

我们先假设现在这堆石头是`[a,b,c,d,e]`, 假设我们的最优解是, 
组合b 和 d,  得到b-d, 所以数组转化成[a,b-d,c,e] (假设b更大)
组合a 和 c,  得到c-a, 所以数组转化成[c-a, b-d, e] (假设c更大)
组合c-a 和 b-d, 得到b-d-c+a, 所以数组转化成[b-d-c+a, e] (假设b-d更大)
组合b-d-c+a 和 e, 得到e-b+d+c-a, 所以数组转化成[e-b+d+c-a] (假设e更大), 这就是最优解

其中我们发现的一个事实是, 最后的结果其实就是把石头前面加上"+"或"-"后所形成的和, 比如示例一其实是"7-2-8+4+1-1", 这样的话, 整个问题就有点像之前做的目标和了.

我们这里就相当于把数分成两组, 一组前缀是"+", 另一组是"-"
![image-20250413113448786](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250413113448845.png)
题目要的是最小值, 所以最后我们应该去找"|a-b|"(a-b的绝对值)的最小值, 不过其实我们不加绝对值也行, 如果出现"a < b"的情况, 那让它们调换一下就行了.

并且我们可以求出"a + b", "a + b"不就是原始数组元素和吗?               当两数的和一定时, 想要让它们差最小, 只要让它们越靠近中间值就行, 比如, 如果它们的和是9, 那么一半就是4.5, 最靠近4.5的两个整数是4和5, 最小差就是1

那么本道题就可以转化成这样一个问题: 在数组中选择一些数, 使得其和尽可能接近, 但小于等于"sum / 2 ", 最后得到的值就是上面例子中的4, 然后就可以用9-4得到5, 5-4就到了本题的答案了.

对于已被转化的问题来说, 可以被视为01背包问题, 对于数组中的元素, 我们可以选或者不选, 这个背包的容积就是"sum / 2", 然后我们要找到是最接近的和, 就是在满足容积的前提下寻找最大利益.

对于示例一来说, 就是
背包容积为11.5

| 编号 |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 体积 |  2   |  7   |  4   |  1   |  8   |  1   |
| 价值 |  2   |  7   |  4   |  1   |  8   |  1   |

在这里, 容积和价值都是元素的值, 问你, 最大的价值和是多少

- **状态表示**

  定义`dp[i][j]`为, 从前`i`个数中选, 总和不超过`j`, 此时的最大和

- **状态表示**

  对于第`i`个数, 有两种操作, 分别是选, 不选
  如果不选`i`, 就相当于在前`i-1`个数中选, 体积不超过`j`, 即`dp[i-1][j]`
  如果选择`i`, 首先能拿到`i`的价值, 也就是`nums[i]`, 但`i`占了`nums[i]`的位置, 所以接下来要做的就是在前`i-1`个数中选, 体积不超过`j-nums[i]`, 的最大值, 即`dp[i-1][j-nums[i]]`, 合起来就是`nums[i] + dp[i-1][j-nums[i]]`, 但`j-nums[i]`不一定合法, 所以我们需要判断一下, 判断合法之后再去统计, 由于我们要的是最大值, 所以选择这两种情况的最大值

- **初始化**

  我们引入虚拟位置, 第一列可以直接交给填表, 不用我们亲自初始化, 对于第一行来说, 表示没有物品的情况, 此时不管容积怎样, 最大值都是零, 所以根本不用初始化

- **填表顺序**

  从上往下

- **返回值**

  我们最后得到了是一个最接近中间值的值,    就是"5, 4"里面的`4`, 此时你先要算出5, 也就是`9-4`, 然后再用5减自己, 就是`9 - 4 - 4`, 所以化简之后就是`sum - 2 * dp[n][V]`

## 代码编写

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(auto e: stones) sum += e;
        int n = stones.size(), V = sum / 2;
        vector<vector<int>> dp(n+1, vector<int>(V+1));
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 0; j <= V; ++j)
            {
                dp[i][j] = dp[i-1][j];
                if(j >= stones[i-1]) dp[i][j] = max(dp[i][j], stones[i-1] + dp[i-1][j-stones[i-1]]);
            }
        }
        return sum -  2 * dp[n][V];
    }
};
```

## 优化

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(auto e: stones) sum += e;
        int n = stones.size(), V = sum / 2;
        vector<int> dp(V+1);
        for(int i = 1; i <= n; ++i)
        {
            for(int j = V; j >= stones[i-1]; --j)
                dp[j] = max(dp[j], stones[i-1] + dp[j-stones[i-1]]);
        }
        return sum - 2 * dp[V];
    }
};
```

# 完
