# 序

今天, 我们进入一个全新的专题, 那就是动态规划的"背包问题", 背包问题可以细分为很多子类型, 其中的难度跨度很大, 有很简单的, 也有难得我们可以直接放弃的, 所以在面试笔试时经常被考到, 因而是动态规划的重点题型. 

它的一般问法是, 你有一个背包, 地上一堆物品, 挑选一些物品放入背包, 问, 最大能挑选出来的价值是多少

之后就是加各种限定词和各种属性, 比如, 物品具有一定的属性, 比如, 价值, 体积, 重量....   背包也有它的最大容积等属性. 比如我们可以规定, 物品用价值和体积两个属性描述, 于是就有

|      |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: |
| 体积 |  4   |  5   |  2   |
| 价值 |  1   |  7   |  9   |

背包的容积是6

另外, 物品还具有个数属性, 上面的表格我们并没有写, 就默认物品个数为一, 这种背包问题被称为01背包, 因为对于一个物品来说, 要么你放入背包`1`, 要么你不放入背包`0`, 就两种状态,                           另外一种是物品个数视为无限, 你可以重复拿物品, 这种叫做完全背包问题, 我们只探讨这两种背包问题

除此之外, 对背包的`size`还有要求, 比如, "背包不必装满", 意思是背包的`size`只要小于等于`capacity`就行, 在这个条件下, 去找最大的价值,      再比如, 还有"背包必须装满", 这要求`size == capacity`, 必须相等

01背包问题是同系列问题的基础.

# [[模板]01背包](https://www.nowcoder.com/share/jump/2813883731744453524330)

![image-20250412192930154](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412192930304.png)

力扣没有纯粹的01背包问题, 所以用牛客, 牛客采用的是ACM模式, 这种模式的特点是什么都要自己手搓.

## 题目解析

他问了两个问题, 一是, 在满足背包容积的前提下, 就是最终的物品体积和小于等于背包容积, 输出最大的价值和           二是, 背包最后必须装满, 此时的最大价值和.

**示例一**

背包容积5

|       |  1   |  2   |  3   |
| :---: | :--: | :--: | :--: |
| 体积v |  2   |  4   |  1   |
| 价值w |  10  |  5   |  4   |

背包问题默认引入虚拟位置, 所以我们从1这个编号开始, 0编号留给虚拟位置

对于第一问, 就是哪种价值和大, 怎么选
那么, 我们可以选择1,3号物品, 这样体积就是3, 价值和就是14, 

对于第二问, 要求背包必须装满, 
那我们只能选2,3号物品, 这样体积就是5, 价值和是9

**示例二**

背包容积8

|       |  1   |  2   |  3   |
| :---: | :--: | :--: | :--: |
| 体积v |  12  |  11  |  6   |
| 价值w |  6   |  8   |  8   |

对于第一问, 其它都超容积了, 只能选择3号, 价值和是8

对于第二问, 根本找不到填满背包的方案, 所以一个物品也不拿. 价值和0

## 算法原理

### 第一问

- **状态表示**

  有点打家劫舍的感觉, 对于某个物品来说, 你可以不拿, 也可以拿, 
  我们可以先蒙一个, 定义`dp[i]`为从`1`号物品开始, 挑到`i`号物品的最大价值和

  但这种状态表示, 感觉好像没有提容量, 没有容量, 那我怎么知道能不能放某个物品呢? 万一放不下怎么办.  所以我们再引入一维, 把容积再包含进来

  定义`dp[i][j]`为 从前`i`个物品中挑选, 总体积不超过`j`, 所有选法中, 能挑选出的最大价值, 我们这个"不超过"是依据第一问的要求来说的, 第一问对容积比较宽松, 不超过就行.

- **状态转移**

  对于最后一个位置, 也就是`i`位置, 我们有两种选择, 一是, 我不要`i`, 二是, 我要`i`, 然后选的是最大的, 所以最后从这两种情况中挑一个最大的就行

  第一种情况, 我不选择`i`, 因为你没选择`i`, 所以你延续`i-1`位置的状态, 这样`dp[i][j] = dp[i-1][j]`

  第二种情况, 我选择`i`, 但`i`不是想选就能选的, 你首先要保证现在的背包能放得下, 现在最大容积就是`j`, 处于`i`物品的体积就是`j-v[i]`, 我这留下的体积要有实际意义, 也就是大于等于零的时候才行, 这样价值和就是`w[i] + dp[i-1][j-v[i]]`, 如果小于零, 那第二种情况就没有可行性, 就不用统计, 另外, 剩余体积可以为零, 这就相当于只拿了`i`这一个物品, 这一个物品就占满了整个包

- **初始化**

  我们会建立虚拟位置, 所以`dp`会多一行和一列, 对于第一行来说, 此时表示一个物品也没选, 那管你容积多少, 不都是零吗? 对于第一列来说, 代表着容积为零, 那包放不进东西, 所以还是零, 这样, 其实就不用初始化

- **填表顺序**

  填表只会用到上边和左上角的格子, 所以一定要从上往下, 至于每行怎么走, 随你

- **返回值**

  回溯题目, 它要的是没有限制的最大价值, 所以容积越大越好, 并且每个物品都走一遍, 这样, 就是`dp[m][n]`

### 第二问

不说的, 和第一问相同

- **状态表示**

  这次它要求一定要装满, 所以此时我们的`j`含义就发生了变化, 从小于等于`j`, 到必须等于`j`, 其它都一样. 
  另外我们需要留意的是, 可能存在无法满足的容积, 我们在示例二也看到了, 对于这种情况, 为了避免和0相混淆, 我们规定, 无法搭配出的容积, 价值和用-1表示. 有哪些地方会用到0呢? 比如`dp[0][0]`, 表示容积为零时的最大价值和, 对于这种情况, 能搭配出来, 只是这种搭配是什么都不选, `-1`表示根本搭配不出来的情况

- **状态转移**

  由于`dp`格子中可能存在无法搭配的情况, 也就是`-1`, 我们在`w[i] + dp[i-1][j-v[i]]`这个分支里要注意`dp[i-1][j-v[i]`是不是-1, 是-1不能用, `dp[i][j] = dp[i-1][j]`这个分支不需要判断, 因为即使真的是-1, 那`dp[i][j]`也会继承这个-1, 但`w[i] + dp[i-1][j-v[i]]`的`w[i]`会把`-1`干扰, 所以必须要主动判断

- **初始化**

  对于第一列来说, 由于容积为零可以被搭配出来, 也就是什么都不要, 所以全部初始化为零, 对于第一行的剩余内容, 由于没有物品, 所以满足不了容积, 统统是-1.

## 代码编写

```cpp
#include <iostream>

using namespace std;

// 使用题目提示的最大空间
const int N = 1001;
int n, V, v[N], w[N];
int dp[N][N];

int main()
{
    // 读入数据
    cin >> n >> V;
    for(int i = 1; i <= n; ++i)
        cin >> v[i] >> w[i];

    // 第一问
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= V; ++j)
        {
            dp[i][j] = dp[i-1][j];
            if(j - v[i] >= 0) dp[i][j] = max(dp[i][j], w[i] + dp[i-1][j - v[i]]);
        }
    }
    cout << dp[n][V]<<endl;
	
    // 重新初始化
    for(int j = 1; j <= V; ++j) dp[0][j] = -1;
    // 第二问
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= V; ++j)
        {
            dp[i][j] = dp[i-1][j];
            if(j - v[i] >= 0 && dp[i-1][j - v[i]] != -1) dp[i][j] = max(dp[i][j], w[i] + dp[i-1][j - v[i]]);
        }
    }
    // -1是我们的约定, 真输出还是要用0
    cout << (dp[n][V] == -1 ? 0 : dp[n][V])<<endl;

    return 0;
}
```

## 优化

对于背包问题来说, 我们会正经说明优化.

几乎所有的背包问题, 都使用滚动数组进行优化, 什么是滚动数组呢?

在状态转移的过程中, 我们发现, 对于某一个格子来说, 顶多用到上一行的格子, 但对于更上面的格子来说, 则完全用不到, 所以我们可以准备两个一维数组, 其中一个填当前值 , 另一个存上一行的值

最开始, 我们有两个数组, 一个视为已经被初始化过的虚拟行, 另一个是要填的起始行

![image-20250412203719263](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412203719354.png)

在起始行, 也就是第一行被填完之后, 第零行就没用了, 那么就可以让它充当第二行

![image-20250412203841346](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412203841416.png)

第一行我们之前已经填过了, 所以我们就可以用第一行去填第二行, 第二行填完之后第一行就没有用了, 它就可以作为第三行来继续新的填表

这是最原始的滚动数组, 实际上, 我们甚至可以只用一行

最开始, 只有第零行, 已经被我们初始化过了
![image-20250412204103326](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250412204103366.png)

然后我们从**最后一个格子**开始填表, 此时相当于这一行既作为上一行, 也作为当前行, 此时相当于把行直接省略了, 直接进行列操作就行

```cpp
#include <iostream>
#include<vector>
using namespace std;

int main()
{
    int n, V;
    cin >> n >> V;
    vector<int> dp(V+1), v(n+1), w(n+1);
    for(int i = 1; i <= n; ++i)
        cin >> v[i] >> w[i];
	
    for(int i = 1; i <= n; ++i)
    {
        // 遍历顺序从右往左
        // 从右往左逐渐变小
        // 所以只要j < v[i]
        // 都不需要继续考虑
        for(int j = V; j >= v[i]; --j)
        {
            dp[j] = max(w[i] + dp[j-v[i]], dp[j]);
        }
    }
    cout << dp[V]<<endl;

    for(int j = 1; j <= V; ++j) dp[j] = -1;

    for(int i = 1; i <= n; ++i)
    {
        for(int j = V; j >= v[i]; --j)
        {
            if(dp[j-v[i]] != -1)
                dp[j] = max(w[i] + dp[j-v[i]], dp[j]);
        }
    }
    cout << (dp[V] == -1 ? 0 : dp[V])<<endl;

    return 0;
}
```

优化后的代码没有实际意义, 有我们也没空记, 所以不要用优化后的代码解释算法原理.

# 完