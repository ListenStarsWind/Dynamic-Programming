# [[模版]完全背包](https://www.nowcoder.com/share/jump/2813883731744545825991)

![image-20250413200603258](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250413200603330.png)

## 题目解析

有一个背包, 容积为`V`, 现有`n`种物品, 每种物品的数量不限, 问一, 这个背包最大能装多大价值的物品, 问二, 现在背包必须装满, 在此前提下, 最大能装多大价值的物品

**示例一**

背包容积为6

|      |  1   |  2   |
| :--: | :--: | :--: |
| 体积 |  5   |  3   |
| 价值 |  10  |  1   |

两种方案
第一种方案, 只拿一个1号物品, 收益为10, 剩余体积为1
第二种方案, 拿两个2号物品, 收益为2, 剩余体积为0

**示例二**

背包容积为8

|      |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: |
| 体积 |  3   |  9   |  10  |
| 价值 |  10  |  1   |  1   |

这里我们只能选择1号物品
可以一次性拿2个1号物品, 这样收益就是20, 剩余体积是2
没有办法填满, 返回0

## 算法原理

### 问一

- **状态表示**

  我们定义`dp[i][j]`表示, 从前`i`个物品中选, 总体积不超过`j`, 所有选法中, 最大的价值

- **状态转移**

  对于最后一个位置, 我们有很多操作方案, 因为这次物品的个数是无限的了, 只要装得下, 那就可以想拿多少拿多少, 所以我们可以          一个也不拿,   拿一个,      拿两个,        拿三个,     拿四个............

  如果一个也不拿, 那么不就相当于在前`i-1`个位置里选物品, 且不超过`j`, 也就是`dp[i-1][j]`
  如果拿一个, 获得`w[i]`, 之后我们还剩下`j-v[i]`的体积, 所以相当于在前`i-1`个位置里选物品, 且体积不超过`j-v[i]`, 即`dp[i-1][j-v[i]] + w[i]`
  如果拿两个, 获得`2*w[i]`, 之后还剩下`j-2v[i]`, 所以就是`dp[i-1][j-2v[i]] + 2w[i]` 
  如果拿三个, 就是`dp[i-1][j-3v[i]] + 3w[i]`
  .................

  接下来, 我们的重点就是把上面的这些操作, 归纳为常数级别的计算

  首先我们有`dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]]+w[i], dp[i-1][j-2v[i]] + 2w[i], ..., dp[i-1][j-kv[i]] + kw[i])`  (这里的k表示满足容积要求下的最大个数)

  然后我们还是用数学的方法, 把上面的`j`等价替换为`j-v[i]`

  `dp[i][j-v[i]] = max(                   dp[i-1][j-v[i]],    dp[i-1][j-2v[i]] + w[i], ..., dp[i-1][j-xv[i]] + xw[i])`    在这里, `k`和`x`其实都是相等的, 这是因为后面替换出来的那个等式仍要保持有效意义, 所以这个`x`依旧是满足容积的最大个数, 再大一点`j-xv[i]`就要变成负数了

  `k`和`x`相等有什么用呢? 这意味着, `dp[i][j]`自`dp[i-1][j-v[i]]`开始和`dp[i][j-v[i]]`的各个项是完全一一对应的, 并且我们还可以看到, 上面的项都比下面的项多`w[i]`, 所有的项都是这样, 那么这不就意味着`dp[i][j-v[i]] + w[i]`就和上面的那些项相等, 所以就能化简出

  `dp[i][j] = max(dp[i-1][j], dp[i][j-v[i]] + w[i])`

  当然, 在实际使用的过程中, 还是不能让`j-v[i]`变成非法的, 所以你需要判断一下, 再用这个式子, 如果不满足, 那就只能用`dp[i-1][j]`了

- **初始化**

  我们只需考虑虚拟位置的第一行即可, 对于第一行来说, 其意义是在没有物品的情况下进行选择, 所以只能都为零

- **填表顺序**

  它可能用到上一行或者本行的左边, 因此, 顺序一定是从上往下, 从左往右

- **返回值**

  题目要的是最大的价值, 那当然是所有物品都已经考虑过了, 容积最大最好, 就是`dp[n][V]`

### 问二

和01背包相同, 略过的和问一相同

- **状态表示**

  `dp[i][j]`表示, 从前`i`个物品中选, 总体积等于`j`, 所有选法中, 最大的价值

- **状态表示**

  我们用-1表示无法搭配, 无法填满背包, 这样的话, 虽然使用的仍旧是``dp[i][j] = max(dp[i-1][j], dp[i][j-v[i]] + w[i])``, 但你要判断一下`dp[i][j-v[i]]`不能为-1.

- **初始化**

  对于第一行来说, 除去`[0][0]`还是之前的0之外, 其它都达不到其它体积, 所以它们都是-1

- **返回值**

  `-1`是我们的约定, 不能真返回-1, 如果最终结果是-1, 那要修正为0

## 代码编写

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int n, V;
    cin >> n>>V;
    vector<int> v(n), w(n);
    for(int i = 0; i < n; ++i) cin >> v[i]>>w[i];

    vector<vector<int>> dp(n+1, vector<int>(V+1));
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 0; j <= V; ++j)
        {
            dp[i][j] = dp[i-1][j];
            if(j >= v[i-1]) dp[i][j] = max(dp[i][j], dp[i][j - v[i-1]] + w[i-1]);
        }
    }
    cout << dp[n][V]<<endl;

    for(int j = 1; j <= V; ++j) dp[0][j] = -1;
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 0; j <= V; ++j)
        {
            dp[i][j] = dp[i-1][j];
            if(j >= v[i-1] && dp[i][j - v[i-1]] != -1) dp[i][j] = max(dp[i][j], dp[i][j - v[i-1]] + w[i-1]);
        }
    }    
    cout << (dp[n][V] == -1 ? 0 : dp[n][V])<<endl;

    return 0;
}
```

## 主体优化

对于上述代码的优化, 我们使用的方案仍旧是滚动数组, 但需要注意的是, 因为可能需要本行的左边, 所以顺序一定要是从左往右, 另外, 我们还是可以把`j >= v[i-1]`融到循环条件里, 也就是`j`从`v[i-1]`开始

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int n, V;
    cin >> n>>V;
    vector<int> v(n), w(n);
    for(int i = 0; i < n; ++i) cin >> v[i]>>w[i];
    vector<int> dp(V+1);
    for(int i = 1; i <= n; ++i)
    {
        for(int j = v[i-1]; j <= V; ++j)
            dp[j] = max(dp[j], dp[j - v[i-1]] + w[i-1]);
    }
    cout << dp[V]<<endl;

    for(int j = 1; j <= V; ++j) dp[j] = -1;
    for(int i = 1; i <= n; ++i)
    {
        for(int j = v[i-1]; j <= V; ++j)
            if(dp[j - v[i-1]] != -1) dp[j] = max(dp[j], dp[j - v[i-1]] + w[i-1]);
    }    
    cout << (dp[V] == -1 ? 0 : dp[V])<<endl;

    return 0;
}
```

## 次级优化

有些人的写发是直接忽略`if(dp[j - v[i-1]] != -1)`这个条件的, 他的思路是, 不使用-1, 而是使用一个很小的数
我们写这个`if`语句的目的是不让无法搭配的情况参与状态推导, 如果使用一个很小的数, 那么即使加了`w[i-1]`, 它依旧会很小, 所以`max`仍然不会选到它, 所以还是不能干预状态推导, 那选什么呢? 答案就是`-0x3f3f3f3f`, 我们之前说过原因, 它既不是太大, 会让`max`选到不应该选到的`dp[j - v[i-1]] + w[i-1]`, 也不会太小, 减几个数直接溢出, 变成一个很大的数, 所以比较合适, 在算法题里面很常见

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int n, V;
    cin >> n>>V;
    vector<int> v(n), w(n);
    for(int i = 0; i < n; ++i) cin >> v[i]>>w[i];
    vector<int> dp(V+1);
    for(int i = 1; i <= n; ++i)
    {
        for(int j = v[i-1]; j <= V; ++j)
            dp[j] = max(dp[j], dp[j - v[i-1]] + w[i-1]);
    }
    cout << dp[V]<<endl;

    for(int j = 1; j <= V; ++j) dp[j] = -0x3f3f3f3f;
    for(int i = 1; i <= n; ++i)
    {
        for(int j = v[i-1]; j <= V; ++j)
            dp[j] = max(dp[j], dp[j - v[i-1]] + w[i-1]);
    }    
    cout << (dp[V] < 0 ? 0 : dp[V])<<endl;

    return 0;
}
```

# 完