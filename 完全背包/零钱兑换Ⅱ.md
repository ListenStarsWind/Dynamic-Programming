# [零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

![image-20250414101955985](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250414101956087.png)

## 题目解析

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 **示例一**


>输入：amount = 5, coins = [1, 2, 5]
>输出：4
>解释：有四种方式可以凑成总金额：
>5=5
>5=2+2+1
>5=2+1+1+1
>5=1+1+1+1+1

**示例二**


>输入：amount = 3, coins = [2]
>输出：0
>解释：只用面额 2 的硬币不能凑成总金额 3 。

**示例三**


>输入：amount = 10, coins = [10] 
>输出：1

## 算法原理

- **状态表示**

  定义`dp[i][j]`为, 在前`i`种硬币中选, 其面值总和为`j`, 所有选法的个数

- **状态表示**

  对于`i`位置来说, 我有很多的操作方案, 不选, 选一个, 选两个, 选三个,  ....., 选`k`个 (`k`表示面值和满足要求的最大个数)

  一个不选, 那就是在前`i-1`位置找面值和为`j`的方案, 所以就是`dp[i-1][j]`
  选一个, 那就是在前`i-1`位置找面值和为`j-coins[i]`的方案, 注意这是`dp[i-1][j-coins[i]]`, 后面没有其他内容

  ..........
  选`k`个, 那就是`dp[i-1][j-k*coins[i]]`

  归纳表示就是`dp[i][j] = dp[i][j] + dp[i-1][j-k*coins[i]]`

- **初始化**

  我们只需要初始化第一行即可, 对于`[0][0]`来说, 什么都不选也是一种选法, 所以是`1`, 对于第一行的其它格子来说, 那就搭配不出来, 所以初始化就是`0`

- **填表顺序**

  从左往右, 从上往下

- **返回值**

  最后一个格子, `dp[n][amount]`

## 代码编写

有一个示例, 是这样的, 它在中间过程溢出了, 题目是说结果不会溢出, 但没说中间过程会溢出, 为此, 我们需要对每次累加的结果进行取模以防止溢出, 既然它说结果不会比`INT_MAX	`大, 那我们就用它作为`mod`, 并把`dp`的元素类型变为`uint`

我们这里就直接写优化后的代码了.

```cpp
class Solution {
    const unsigned int mod = INT_MAX;
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        vector<unsigned int> dp(amount + 1); dp[0] = 1;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = coins[i-1]; j <= amount; ++j)
            {
                dp[j] += dp[j-coins[i-1]];
                dp[j] %= mod;
            }
        }
        return dp[amount];
    }
};
```

# 完
