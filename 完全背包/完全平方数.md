# [完全平方数](https://leetcode.cn/problems/perfect-squares/)

![image-20250414113727582](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250414113727699.png)

## 题目解析

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例一**


>输入：n = 12
>输出：3 
>解释：12 = 4 + 4 + 4

首先我们先确定有那些完全平方数可供选择, 因为`3*3 = 9, 4*4 = 16`, 所以我们选择`1*1 = 1, 2*2 = 4, 3*3 = 9`这三个完全平方数作为预选值, 如果选`9`的话需要用`1`来搭配, 选`1`的话就更多了, 所以我们选择三个`4`

**示例二**


>输入：n = 13
>输出：2
>解释：13 = 4 + 9

## 算法原理

这道题不能用贪心, 比如对于示例一来说, 如果用贪心, 那先选一个更大的, 那就是9, 可接下来再选4就溢出了.    所以可以暴力查找, 从预选值里挑选一个, 组成12, 说到挑选, 那我们就应该想到背包问题.所以下面我们用背包问题来求解该题

- **状态表示**

  定义`dp[i][j]`为, 在前`i`个完全平方数里选, 其总和为`j`的, 所有选法中, 最小的数量

- **状态转移**

  对于第`i`个数来说, 有很多操作, 你可以不选, 可以选一个, 可以选两个, .....,  可以选`k`个
  如果你不选, 那么就是在前`i-1`数里选总和为`j`的, 即`dp[i-1][j]`
  选一个, 那就是在前`i-1`数里选总和为`j-i*i`的, 但要注意, 我们这里是个数, 所以末尾要加一, `dp[i-1][j-i*i] + 1`
  选两个, 那就是在前`i-1`数里选中和为`j-2*i*i`的, 是`dp[i-1][j-2*i*i] + 2`
  .........
  选`k`个, 就是`dp[i-1][j-k*i*i] + k`

  归纳化简就是`dp[i][j] = min(dp[i-1][j], dp[i][j-k*i*i])`

- **初始化**

  对于第一行来说, `[0][0]`确实可以搭配出来, 它表示在不选任何数的情况下, 总和为`0`的选法中使用数字个数最小的, 很明显, 一个数字都不用就是最好的方案, 所以就是零, 但对于第一行的其它内容来说, 表示在不选任何数字的情况下, 还要总和为正数, 那这很明显搭配不出来, 所以我们要给它初始化成一个表示无法被真实使用的数字, 由于我们用的是`min`, 所以给一个足够大的数就行了, 比如`INF = 0x3f3f3f3f`

- **填表顺序**

  从左往右, 从上往下, 另外, 我们还要想一下`dp`的规格, 其实我们在题目解析哪里就已经体现了, 我们先求了一个最接近`13`开方数的数, 也就是`3`作为我们的完全开方数的个数, 所以这里也是一样, 这样我们的`dp`规格就是行是开方`n`+1, 列是`n+1`

- **返回值**

  返回最右下角的格子

## 代码编写

```cpp
class Solution {
    const int INF = 0x3f3f3f3f;
public:
    int numSquares(int n) {
        int m = sqrt(n);
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for(int j = 1; j <= n; ++j) dp[0][j] = INF;
        for(int i = 1; i <= m; ++i)
        {
            for(int j = 0; j <= n; ++j)
            {
                dp[i][j] = dp[i-1][j];
                if(j >= i*i) dp[i][j] = min(dp[i][j], dp[i][j-i*i] + 1);
            }
        }   
        return dp[m][n];
    }
};
```

## 空间优化

```cpp
class Solution {
    const int INF = 0x3f3f3f3f;
public:
    int numSquares(int n) {
        int m = sqrt(n);
        vector<int> dp(n+1, INF); dp[0] = 0;
        for(int i = 1; i <= m; ++i)
        {
            for(int j = i*i; j <= n; ++j)
                dp[j] = min(dp[j], dp[j-i*i] + 1);
        }
        return dp[n];
    }
};
```

# 完
