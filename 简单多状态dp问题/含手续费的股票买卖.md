# [含手续费的股票买卖](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

![image-20250403213409189](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403213409423.png)

## 题目解析

给你一个整数矩阵, 用来描述一支股票在一段时间内每日价格的具体情况. 你可以对这支股票进行买入或者卖出, 每轮交易(指买入持有并卖出股票的整个过程)都需要支付一份手续费, 请你设计一个算法, 求出股票交易的最大利润, 注意, 这里描述的是一支股票, 所以你一旦买入它, 除非卖出它, 否则就不能再次买入.

**示例一**

>```
>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
>输出：8
>解释：能够达到的最大利润:  
>在此处买入 prices[0] = 1
>在此处卖出 prices[3] = 8
>在此处买入 prices[4] = 4
>在此处卖出 prices[5] = 9
>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
>```

第一天, 你买入股票, 花费了1, 账户余额为-1, 第二天, 你不决定卖出它, 因为卖出它要支付一份手续费, 利润和手续费对冲, 最后收支仍是零, 等于白干, 所以你这天什么都没干, 第三天, 行情更不好, 所以你还是什么都不做, 第四天, 你卖出股票, 得到了8, 账户余额为7, 但还需要支付手续费, 所以余额变为5, 第五天, 你再次买入, 花费4, 账户余额1, 第六天, 你卖出股票, 得到了9, 余额变为10, 但还需要支付一份手续费, 所以最终利润为9

**示例二**

>```
>输入：prices = [1,3,7,5,10,3], fee = 3
>输出：6
>```

![image-20250403215348202](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403215348263.png)

![image-20250403215432759](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403215432810.png)

## 算法原理

- **状态表示**

  这里我们仍旧根据经验和题意, 定义`f[i]`为从起点开始, 到第`i`天结束之后, 所能获得的最大利润(第`i`天结束时要持有股票),  `g[i]`为从起点开始, 到第`i`天结束之后, 所能获得的最大利润(第`i`天结束时没有持有股票).

- **状态转移**

  还是和之前一样, 我们先画一下表示这两个状态相互关系的图, 帮助我们理清关系.

  ![image-20250403220331419](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403220331501.png)

  这个手续费要求是每进行一轮交易就需要缴纳, 是买入时缴纳还是卖出时缴纳其实都是一样的, 在这里我们就默认为卖出时缴纳.
  
  当一天结束时, 我发现自己处于持有股票的状态, 那么前一天就有两种可能, 一种是前一天就处于持有状态, 你这一天什么都没干, 另一种可能就是前一天你处于不持有状态, 但买入股票, 变成了持有状态, 因此, 就有`[i] = max(f[i-1], g[i-1] - prices[i]);`
  
  当一天结束时, 我发现自己处于不持有状态, 那么前一天就有两种可能, 一种是前一天我就处于持有状态, 我今天什么都没干, 另一种可能就是前一天你处于持有状态, 但卖出了股票, 变成了不持有状态, 对于这两种状态, 我们当然选择其中最大的, 于是有`g[i] = max(g[i-1], f[i-1] + prices[i] - fee);`
  
- **初始化**

  在第一天, 也就是下标为零的那一天结束时, 如果你持有股票, 说明你买入了股票, 所以此时的利润就是`-p[i]`, 如果你不持有股票, 说明你第一天什么都没干, 利润不就是零吗, 所以有`f[0] = -prices[0]; g[0] = 0;`

- **填表顺序**

  从左往右, 两表同填.

- **返回值**

  理论上来说, 你卖出股票应该比还持有股票利润更高, 但这里还有个手续费, 这个手续费可能把我们的差价拉成负数, 所以为了保险起见, 我们加个`max`, 把最后一格的最大值返回

## 代码编写

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<int> f(n), g(n);
        f[0] = -prices[0];
        for(int i = 1; i < n; ++i)
        {
            f[i] = max(f[i-1], g[i-1] - prices[i]);
            g[i] = max(g[i-1], f[i-1] + prices[i] - fee);
        }
        return max(f[n-1], g[n-1]);
    }
};
```

# 完