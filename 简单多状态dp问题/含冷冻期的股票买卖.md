# [含冷冻期的股票买卖](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown)

![image-20250403121410554](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403121410617.png)

## 题目解析

给你一个整数数组, 该数组描述了一支股票在连续天数的价格走势, 其中第 `prices[i]` 表示第 `i` 天的股票价格 . 请设计一个算法, 计算出股票交易的最大利润.    注意, 卖出股票后, 你无法在第二天买入股票 (即冷冻期为 1 天), 数组描述的是一支股票的价格, 所以当股票已经被你持有的时候, 不能再次买入.

**示例一**

>```
>输入: prices = [1,2,3,0,2]
>输出: 3 
>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
>```

在第一天, 你买入了股票, 持有了这支股票, 此时你的利润为-1,  在第二天, 你卖出了股票, 获得点数2, 于是利润变成了1, 第三天, 由于你前一天卖出了股票, 所以今天进入了冷冻期, 什么都不能干, 所以利润还是之前的1, 第四天, 你买入了股票, 此时利润为1, 第五天, 你卖出了股票, 获取差价2个点数, 所以此时的利润为3. 

示例二

>```
>输入: prices = [1]
>输出: 0
>```

你的活动窗口只有一天, 这意味着如果你在第一天买入股票, 那么就没有机会卖出股票, 从而亏损, 为此, 你决定在第一天什么也不做.

## 算法原理

- **状态表示**

  我们的状态有三种可能, 一是持有这支股票, 二是不持有这支股票, 但可以马上买入, 三是不持有这支股票, 且在冷冻期, 无法进行任何交易. 我们定义`dp[i]`为从第一天开始, 到i位置已经进行完操作的时候, 此时获得的最大利润. 为了详细划分上述的三种状态, 我们需要定义`dp[i][0]`为一天结束后, 为"持有股票"前提下, 所能获得的最大利润, `dp[i][1]`为一天结束后, 为"可交易"前提下, 所能获得的最大利润, `dp[i][2]`为一天结束后, 为"冷冻期"前提下, 所能获得的最大利润. 

- **状态转移**

  本题的状态关系较为复杂, 直接进行状态转移方程的分析较为困难, 所以我们先要通过图的形式理清这三种状态的相互关系.

  ![image-20250403130011994](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403130012039.png)

  ​	一般来说, 我们为了避免漏掉某些关系, 我们会先锁定一个状态,  然后看看这个状态能不能回到自身(就是能不能连续), 其它状态能不能变成这个锁定的状	态. 比如对于"持有"来说, 你昨天持有, 那今天可以继续持有, 也就是什么都不做, 延续之前的利润.       冷冻期能不能变成持有呢? 不行, 因为冷冻期无法进	行任	何交易, 不持有能不能变成持有呢? 只要买入股票就可以, 而今天的股票价格是`prices[i]`

  ![image-20250403130634702](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403130634745.png)

  ​	冷冻期能不能回到自身呢? 不行, 因为冷冻期只有一天, , 所以它无法延续, 持有能不能到冷冻期呢? 可以, 卖出股票即可, 不持有能不能到冷冻期呢? 也不行

  ​	                           ![image-20250403131327454](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403131327496.png)

  不持有能不能持续呢? 可以, 什么都不做就行, 持有能不能直接变成不持有呢? 不行, 冷冻期什么都不做会自动变为不持有

  ![image-20250403131557309](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403131557345.png)

  画好图之后, 状态转移方程就好分析了.

  如果今天结尾你是"持有"状态, 那么前一天你有两种可能, 一是前一天就是持有, 对于这种情况, 今天的利润就是昨天的利润, 二是前一天是不持有. 你是依靠买入行为转移成了"持有"状态, 所以要扣之前的利润, 这样的话, 就可以得到`dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);`

  如果今天结尾你是"不持有", 那么, 前一天有两种可能, 一是前一天就是不持有, 延续之前的利润, 二是, 前一天是冷冻期, 你也什么都没做, 就变成了不持有状态, 于是可得`dp[i][1] = max(dp[i-1][1], dp[i-1][2]);`

  如果今天你是"冷冻期", 那么前一天就只能是"持有", 你通过卖出股票的行为来到了冷冻期,  `dp[i][2] = dp[i-1][0] + prices[i];`

- **初始化**

  这次我们就直接初始化实位置, 对于第一天来说, 如果买入要花钱, 所以`dp[0][0] = -prices[0]`, 不持有那就是什么也不干, 所以`dp[0][1] = 0;`, 至于冷冻期, 达不到, 或者也可以认为是一天之内既买入又卖出, 所以也是零, `dp[0][2] = 0;`

- **填表顺序**

  从左往右, 三表同填

- **返回值**

  最后一天有三个状态, 选取其中的最大值即可, 其实不必考虑持有状态, 因为不卖出哪来的钱, 所以这肯定比卖出的情况要低

## 代码编写

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(3));
        dp[0][0] = -prices[0];
        for(int i = 1; i < n; ++i)
        {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][2]);
            dp[i][2] = dp[i-1][0] + prices[i];
        }
        return max(dp[n-1][1], dp[n-1][2]);
    }
};
```

# 完