# [买卖股票的最佳时机Ⅳ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv)

![image-20250404141855258](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250404141855311.png)

## 题目解析

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例一**

>```
>输入：k = 2, prices = [2,4,1]
>输出：2
>解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
>```

最多可以完成两次交易, 但一次交易就已经足够

**示例三**

>```
>输入：k = 2, prices = [3,2,6,5,0,3]
>输出：7
>解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
>     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
>```

最多可以完成两次交易, 两次交易方案的利润最大, 所以选择该方案

**示例三**

>输入：k = 100, prices = [5,4,3,2,1]
>输出：0
>解释：价格越来越低, 全程观望, 利润为零

最多可以完成100次交易, 但只要交易就会亏损, 所以一次交易也不做.

## 算法原理

- **状态表示**

  状态表示使用的数组维度依据其是否可以清晰表达题目中的信息而定, 对于本题而言, 若是采用一维数组方案, 只能表示第`i`天所能获得的最大利润, 但很明显, 如果采用这种方式, 信息就太贫乏了, 所以我们要增加一维, 定义`f[i]`为在第`i`天结束时, 处于持有状态的最大利润, 定义`g[i]`为, 在第`i`天结束时, 处于非持有状态的最大利润, 但这里仍不够表示交易次数这个信息, 所以我们继续增加一维, 定义`f[i][j]`为, 在第`i`天结束时, 处于持有状态, 并且这个持有状态是在第`j`次交易中的最大利润, 定义`g[i][j]`为, 在第`i`天结束时,  处于非持有状态, 且这个非持有状态是在第`j`次交易中的最大利润, `j`表示已经完成的交易次数.

- **状态转移**

  还是老样子, 我们先画一下表示状态关系的图

  ![image-20250404130805592](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250404130805631.png)

  如果你已经持有一支股票, 那能不能继续持有呢? 当然可以, 你这一天什么都不做就行了.  不持有能不能到持有呢? 也可以, 买入股票即可,  对于不持有来说, 如果你本来就不持有股票, 能不能继续不持有呢? 当然可以, 你这一天什么都不做就行了, 持有能不能到不持有呢? 也可以, 卖出股票即可, 需要注意的是当你卖出一支股票, 就意味着完成了一轮交易, 所以你就需要对交易次数加一.

  当你一天结束之后处于持有状态, 那有两种可能, 一是, 前一天你就是持有, 另外的一种可能是, 前一天你不持有, 你这天依靠买入变为了持有状态, 因此, 就可得状态转移方程`f[i][j] = max(f[i-1][j], g[i-1][j] - prices[i]);`

  当你一天结束后处于非持有状态, 哪有两种可能, 一是, 前一天你就是没持有, 另外的一种可能是, 前一天你是有股票, 但依靠卖出变成了不持有, 因此, 就可得对应的状态转移方程`g[i][j] = max(g[i-1][j], f[i-1][j-1] + prices[i])`

- **初始化**

  在初始化阶段, 我们要考虑可能的越界问题. 光差状态转移方程, 可以知道, 它有两种越界可能, 一是行越界, 而是列越界. 该如何处理越界呢?  根据之前我们所做的题目, 也就是个人经验, 我们知道, 处理越界现在我们有两种思路, 一是增加虚拟位置, 二是直接初始.  选哪一个呢?   我们决定选择直接初始化, 当初我们选择虚拟位置方案, 是为了图省事, 但这里感觉, 如果再引入虚拟位置, 虚拟位置的初始化似乎会更加困难, 所以我们就不用这种思路了.

  如果选择直接初始化, 由于行和列都可能越界, 所以我们应该对第一行和第一列都进行初始化, 但我觉得, 对于列来说, 它实际上只有在一个地方上才可能出现越界问题, 我觉得其实不必这么大费周章, 连第一列都要初始化. 为此我们可以回到状态转移方程哪里, 对原先的状态转移方程引入限制条件, 限制它, 使之不会越界.

  列越界只存在一种可能`g[i][j] = max(g[i-1][j], f[i-1][j-1] + prices[i])`, 观察这个状态转移方程, 我们发现, (在行初始化完成的前提下), `g[i-1][j]`是不会越界的, 越界的只可能是`f[i-1][j-1] + prices[i]`, 所以我们可以先让`g[i][j]`变为`g[i-1][j]`, 然后加个`if`语句判断`j-1`有没有越界, 在没有越界的前提之下再进行大小比较, 这样, 我们就不必考虑列越界了.

  对于行越界, 我们则是要正经初始化. 我们的初始化原则是不能影响到后续环节的判断, 很明显, 在第一天, 不可能存在交易次数为1或者2的可能, 这意味着, 第二行的第二列, 它在进行填表时, 它的状态只能从第一行的第一列继承, 而不能从第一行的第二列继承, 因为这是一个不应该存在的位置

  ![image-20250404135352190](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250404135352250.png)

  我们是依靠谁来选择上一次状态的呢? 是依靠`max`, 因此, 我们想让`max`不选上一个值只需要将它的值变得足够小就行了, 比如`INT_MIN`, 因为值很小, 所以它只是参与比较, 但不会被真正使用. (第二行第三列确实会继承第一行第三列的值, 但一个足够小的数加上`p[i]`, 仍然是足够小的, 所以对于第三行第三列来说, 它仍然会从第二行第二列那里继承状态)

  但我们也不能真的使用`INT_MIN`, 因为我们有个方程是减去`p[i]`, 所以就会溢出, 因此这里对于"足够小"的力度有些要求, 对于这种情况来说, 我们一般喜欢用`0x3f3f3f3f`这个数, 足够大就是`0x3f3f3f3f`, 足够小就是`-0x3f3f3f3f`, 以此来防止数值溢出.

  之后我们对`f, g`进行一下具体分析, `f[0][0]`表示第一天买入, 所以应该是`-p[i]`, `g[0][0]`表示第一天什么都不做, 所以是`0`, 至于第一行的其它列, 那都是`-0x3f3f3f3f`.

- **填表顺序**

  从左往右, 从上到下

- **返回值**

  首先我们就不考虑持有状态了, 很明显, 卖出再获利显然利润更高, 之后, 由于可能进行零次交易, 一次交易, 二次交易......, 所以你要遍历一遍, 找出其中的最大值

  ## 代码编写

  ```cpp
  class Solution {
      const int INF = 0x3f3f3f3f;
  public:
      int maxProfit(int k, vector<int>& prices) {
          int n = prices.size(); ++k;
          vector<vector<int>> g(n, vector<int>(k, -INF));
          auto f = g; f[0][0] = -prices[0];g[0][0] = 0;
          for(int i = 1; i < n; ++i)
          {
              for(int j = 0; j < k; ++j)
              {
                  f[i][j] = max(f[i-1][j], g[i-1][j] - prices[i]);
                  g[i][j] = g[i-1][j];
                  if(j-1 >= 0) g[i][j] = max(g[i][j], f[i-1][j-1] + prices[i]);
              }
          }
  
          int result = -INF;
          for(int i = 0; i < k; ++i)
          {
              result = max(result, g[n-1][i]);
          }
          return result;
      }
  };
  ```

  # 完