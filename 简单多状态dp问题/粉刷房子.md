# [粉刷房子](https://leetcode.cn/problems/JEj789)

![image-20250403100202315](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403100202411.png)

## 题目解析

假如有一排房子，共 `n` 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 `n x 3` 的正整数矩阵 `costs` 来表示的。

例如，`costs[0][0]` 表示第 0 号房子粉刷成红色的成本花费；`costs[1][2]` 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本。

**示例一**

>```
>输入: costs = [[17,2,17],[16,16,5],[14,3,19]]
>输出: 10
>解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
>     最少花费: 2 + 5 + 3 = 10。
>```

![image-20250403104124551](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403104124630.png)

有三个房子, 

第一个房子粉刷红色, 花费的点数是17, 粉刷蓝色, 花费的点数是2, 粉刷绿色, 花费的点数是17
第二个房子粉刷红色, 花费的点数是16, 粉刷蓝色, 花费的点数是16, 粉刷绿色, 花费的点数是5
第三个房子粉刷红色, 花费的点数是14, 粉刷蓝色, 花费的点数是3, 粉刷绿色, 花费的点数是19

我们的方案是第一个房子粉刷蓝色, 第二个粉刷绿色, 第三个粉刷蓝色. 总数是10.

**示例二**

>```
>输入: costs = [[7,6,2]]
>输出: 2
>```

很明显, 只有一个房子, 选一个最小的就行了, 所以是2.

## 算法原理

- **状态表示**

  很明显, 可以定义`dp[i]`为从起点开始, 到达`i`位置的最小花费, 稍有不同的是, 每个状态本身可以向下细分出三种情况, 所以`dp[i][0]`表示到达`i`位置选择红色的最小花费, `dp[i][1]`表示到达`i`位置选择蓝色的最小花费, `dp[i][2]`表示到达`i`位置选择绿色的最小花费.

- **状态转移**

  你到达`i`位置, 并且选择了红色, 那么你前一个就只能选择蓝色或者绿色, 从里面挑一个小的就行, 所以`dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + costs[i][0];`   其它情况于此同理, 在此省略.

- **初始化**

  我们可以初始化第一个实位置, 也可以建立三个虚拟位置

  ![image-20250403105621474](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403105621542.png)

  我们这里选择虚拟位置方案, 接下来我们要注意两点, 一是在写代码的时候主语下标的映射关系, 而是要想想这些虚拟位置的值到底该怎么填. 让我们想一想, 什么时候才用到这些虚拟位置? 那就是第一个实位置的时候, 对于第一个实位置, 由于它前面没有房子, 所以它选择红色, 就是对应红色的花费, 选择蓝色, 就是蓝色花费, 选择绿色, 就是绿色花费. 或者说, 就是与之对应的`costs`的值

  现在我们再看看状态转移方程, 状态转移方程前面还有一个`min`, 这意味着第一个实位置的`min`应该为零, 所以虚拟位置应该填零.

- **填表顺序**

  很明显, 从左往右, 三个表同时填.

- **返回值**

  取最后一个格子中的最小值就行了

## 代码编写

````cpp
class Solution {
public:
    int minCost(vector<vector<int>>& costs) {
        int n = costs.size();
        vector<vector<int>> dp(n+1, vector<int>(3));
        for(int i = 1; i <= n; ++i)
        {
            dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + costs[i-1][0];
            dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + costs[i-1][1];
            dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + costs[i-1][2];
        }
        return min(min(dp[n][0], dp[n][1]), dp[n][2]);
    }
};
````

# 完

​	