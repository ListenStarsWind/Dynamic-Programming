# [按摩师](https://leetcode.cn/problems/the-masseuse-lcci)

![image-20250402151406492](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402151406557.png)

## 题目解析

这是打家劫舍的变形题.

题目就不复述了, 总之, 这个按摩师她决不能选择两个相邻的预约, 也就是说, 她必须跳着接受预约, 至于中间跳了多少个预约, 没有要求.

**示例一**

>```
>输入： [1,2,3,1]
>输出： 4
>解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
>```

有三种选法

![image-20250402152519880](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402152519910.png)

其中最大的是4

**示例二**

>```
>输入： [2,7,9,3,1]
>输出： 12
>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
>```

![image-20250402152809886](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402152809918.png)

这里不止三种选法, 但我们这里就画三种了.

**示例三**

>```
>输入： [2,1,4,5,3,1,1,3]
>输出： 12
>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
>```

![image-20250402153323797](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402153323830.png)

## 算法解析

- **状态表示**

  还是按照经验和题目要求, `dp[i]`表示选择到`i`位置最长的预约时间, 与以往不同的是, 这次我们在状态表示里也要分类讨论了

  选到`i`位置, 我既可以选择它, 也可以不选择它,  我们用数组`f`和数组`g`分别描述它们.这样`f[i]`表示走到`i`位置时, 选择它, 此时的最长预约时长, `g[i]`表示, 走到`i`位置, 不选择它, 此时的最长预约时长.

  在这里某个时间点, 是可以分成两条分支的, 而之前我们做的那些题, 只有从一个状态转移到另一个状态, 在转移的过程中有分类讨论的情况, 而在这里, 状态本身就是含有分支的.

- **状态转移**

  首先我们看`f[i]`, 对于`f[i]`来说, 因为`i`位置是必选的, 所以它自身肯定要算上, 除此之外, 你还要从前面`[0, i-1]`里找一个最长时间, 并且这个最长时间还必须不选择`i-1`这个位置, 这不就是`g[i-1]`吗?

  ![image-20250402160002801](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402160002837.png)

  所以对于`f[i]`, 其状态转移方程是`f[i] = nums[i] + g[i-1]`

  而对于`g[i]`来说, 它必不选择`i`位置, 所以它的值就是`[0, i-1]`区间的最长值, 但需要注意的是, 到达`i-1`位置这个状态本身是有两个分支的, 一个是`g[i-1]`另一个是`f[i-1]`, 你要在其中选择更大的那一个, 所以其对应的状态转移方程就是`g[i] = max(g[i-1], f[i-1])`

  ![image-20250402161050806](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250402161050848.png)

- **初始化**

  这次由于问题比较简单, 建立虚拟位置反而更繁琐, 所以我们选择直接初始化,  此时`f[0]`因为它必选自身, 所以`f[0] = muns[0]`, 至于`g[0]`, 也很好判断, 前面没值, 你又不选自己, 那不就是零吗?

- **填表顺序**

  对`f[i] and g[i]`从左往右同时填.

- **返回值**

  虽说我们只有一个终点, 但终点本身有两个分支, 而题目问的是最长的, 所以你要返回其中最长的.

## 代码编写

```cpp
class Solution {
public:
    int massage(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        vector<int> f(n), g(n);
        f[0] = nums[0];
        for(int i = 1; i < n; ++i)
        {
            f[i] = g[i-1] + nums[i];
            g[i] = max(f[i-1], g[i-1]);
        }
        return max(f[n-1], g[n-1]);
    }
};
```

# 完