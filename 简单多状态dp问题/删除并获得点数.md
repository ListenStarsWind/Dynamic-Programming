# [删除并获得点数](https://leetcode.cn/problems/delete-and-earn)

![image-20250403084811455](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403084811573.png)

## 题目解析

给你一个整数数组 `nums` ，你可以对它进行一些操作。

每次操作中，选择任意一个 `nums[i]` ，删除它并获得 `nums[i]` 的点数。之后，你必须删除 **所有** 等于 `nums[i] - 1` 和 `nums[i] + 1` 的元素。也就是说, 当你选择一个点数后, 与它数值相邻的点数都不能再选.

开始你拥有 `0` 个点数。返回你能通过这些操作获得的最大点数。

![image-20250403085656092](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403085656135.png)

比如对于这个数组而言, 如果你选择了5, 那么(为了利益最大化), 就获得了10个点数, 但代价是相邻的4和6变得不可选择(因为被删除了), 

![image-20250403085958942](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403085958985.png)

我们再选择一下`2`和`7`

![image-20250403090137542](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403090137606.png) 

最大值就是30.

**示例一**

>```
>输入：nums = [3,4,2]
>输出：6
>解释：
>删除 4 获得 4 个点数，因此 3 也被删除。
>之后，删除 2 获得 2 个点数。总共获得 6 个点数。
>```

为了方便看, 我们先把原始数组排序一下

![image-20250403090415713](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403090415744.png)

有两种选法

![image-20250403090524477](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403090524511.png)

我们选择更大的6.

**示例二**

>```
>输入：nums = [2,2,3,3,3,4]
>输出：9
>解释：
>删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
>总共获得 9 个点数。
>```

有两种选法

![image-20250403091026598](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403091026631.png)

我们选择更大的9.

## 预处理

这道题有动规的感觉, 但差点意思.  如果原始数组类似于`[1,2,3,4,5]`, 那整个问题其实就被转换成打家劫舍, 还是一那个版本.  但可惜就可惜在, 数组中的元素一可能不连续, 二可能不升序.所以不能直接用动规来解. 需要经过预处理, 转化成类似于`[1,2,3,4,5]`这种, 把数值上的相邻转化成位置上的相邻.

比如说`[1,1,2,2,4,4,5,8]`, 我们怎么转成非常理想的那种状况呢?    思路可以说其实是哈希, 但用数组实现, 直接依据元素的大小映射到数组的对应位置上, 比如`1`那就映射到数组的一下标, `8`就映射到数组的八下标, 所以首先我们先要把原始数组遍历一下, 找到其中的最大值, 再开一个足够大的数组, 可以容纳下原始数组中的所有元素, 数组的元素是什么呢? 是原始数组中相同组的数值和, 比如, 在原始数组中, `[4,4]`是一组, 那么预处理之后, `nums[4] = 8`, 对于那些在原始数组中缺失的羽山路, 比如`7`, 那我们就默认点数为零, 即`nums[7] = 0`, 点数为零, 就相当于没拿, 于是经过预处理之后, 原先的原始数组就变成了这样一个样子

![image-20250403092840746](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403092840782.png)

这样数值上的相邻就被转化成了位置上的相邻, 如果我选择原始数组的`4`, 那我就需要删除`3`和`5`, 对应到现在已经被预处理的数组, 那就是如果我选择下标`4`中的点数, 那下标`3, 5`中的点数就不能再选择了.

## 算法原理

- **状态表示**

  定义`f[i]`为选到`i`位置并且选择`i`时的最大获取点数, 定义`g[i]`为选到`i`位置并且不选择`i`时的最大获取点数. 

- **状态转移**

  如果你选到`i`位置并且还选择了`i`, 那么, 此时的最大点数就是从`0`到`i-1`位置的最大点数, 并且, 这个最大点数是有条件的, 他必须不选择`i-1`位置, 那这不就是`g[i-1]`吗?  所以`f[i] = nums[i] + g[i-1]`

  如果你选到`i`位置, 并且 一定不选择`i`, 那么此时的最大点数就是`0`到`i-1`位置的最大点数, 而且此时对是否选择`i-1`没有要求, 所以我们只需要从`g[i-1]`和`f[i-1]`中选一个最大的, 就行了. 所以`g[i] = max(g[i-1], f[i-1])`

- **初始化**

  对于第一个格子来说, 也就是下标为零的格子来说, 由于它前面已经没有格子, 所以需要进行初始化, 以防止其越界, 对于第一个格子来说, 如果选择了它, 那点数就是它自身, 如果没有选择, 那因为前面没有点数, 所以一个点数都得不到, 也就是零, 但零其实也不用特意初始化, 因为`int`的默认构造是零.

- **填表顺序**

  依据状态转移方程, 推导当前位置需要上一个位置的参与, 所以填表顺序很明显是从左往右

- **返回值**

  很明显, 是最后一个格子的最大点数, 最后一个格子有两种情况, `g[n-1]`和`f[n-1]`, 选择其中更大的那一个就行了.

## 代码编写

```cpp
class Solution {
    int _max(const vector<int>& nums_)
    {
        int result = 0;
        for(auto e : nums_)
            result = max(result, e);
        
        return result;
    }

    int rob(const vector<int>& nums)
    {
        int n = nums.size();
        vector<int> f(n), g(n);
        f[0] = nums[0];
        for(int i = 1; i < n; ++i)
        {
            f[i] = nums[i] + g[i-1];
            g[i] = max(f[i-1], g[i-1]);
        }
        return max(f[n-1], g[n-1]);
    }

public:
    int deleteAndEarn(vector<int>& nums_) {
        int temp = _max(nums_);
        vector<int> nums(temp+1);
        for(auto e : nums_)
        {
            nums[e] += e;
        }
        return rob(nums);
    }
};
```

# 完