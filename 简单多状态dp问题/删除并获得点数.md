# [删除并获得点数](https://leetcode.cn/problems/delete-and-earn)

![image-20250403084811455](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403084811573.png)

## 题目解析

给你一个整数数组 `nums` ，你可以对它进行一些操作。

每次操作中，选择任意一个 `nums[i]` ，删除它并获得 `nums[i]` 的点数。之后，你必须删除 **所有** 等于 `nums[i] - 1` 和 `nums[i] + 1` 的元素。也就是说, 当你选择一个点数后, 与它数值相邻的点数都不能再选.

开始你拥有 `0` 个点数。返回你能通过这些操作获得的最大点数。

![image-20250403085656092](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403085656135.png)

比如对于这个数组而言, 如果你选择了5, 那么(为了利益最大化), 就获得了10个点数, 但代价是相邻的4和6变得不可选择(因为被删除了), 

![image-20250403085958942](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403085958985.png)

我们再选择一下`2`和`7`

![image-20250403090137542](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403090137606.png) 

最大值就是30.

**示例一**

>```
>输入：nums = [3,4,2]
>输出：6
>解释：
>删除 4 获得 4 个点数，因此 3 也被删除。
>之后，删除 2 获得 2 个点数。总共获得 6 个点数。
>```

为了方便看, 我们先把原始数组排序一下

![image-20250403090415713](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403090415744.png)

有两种选法

![image-20250403090524477](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403090524511.png)

我们选择更大的6.

**示例二**

>```
>输入：nums = [2,2,3,3,3,4]
>输出：9
>解释：
>删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
>总共获得 9 个点数。
>```

有两种选法

![image-20250403091026598](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403091026631.png)

我们选择更大的9.

## 预处理

这道题有动规的感觉, 但差点意思.  如果原始数组类似于`[1,2,3,4,5]`, 那整个问题其实就被转换成打家劫舍, 还是一那个版本.  但可惜就可惜在, 数组中的元素一可能不连续, 二可能不升序.所以不能直接用动规来解. 需要经过预处理, 转化成类似于`[1,2,3,4,5]`这种, 把数值上的相邻转化成位置上的相邻.

比如说`[1,1,2,2,4,4,5,8]`, 我们怎么转成非常理想的那种状况呢?    思路可以说其实是哈希, 但用数组实现, 直接依据元素的大小映射到数组的对应位置上, 比如`1`那就映射到数组的一下标, `8`就映射到数组的八下标, 所以首先我们先要把原始数组遍历一下, 找到其中的最大值, 再开一个足够大的数组, 可以容纳下原始数组中的所有元素, 数组的元素是什么呢? 是原始数组中相同组的数值和, 比如, 在原始数组中, `[4,4]`是一组, 那么预处理之后, `nums[4] = 8`, 对于那些在原始数组中缺失的羽山路, 比如`7`, 那我们就默认点数为零, 即`nums[7] = 0`, 点数为零, 就相当于没拿, 于是经过预处理之后, 原先的原始数组就变成了这样一个样子

![image-20250403092840746](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250403092840782.png)

这样数值上的相邻就被转化成了位置上的相邻, 如果我选择原始数组的`4`, 那我就需要删除`3`和`5`, 对应到现在已经被预处理的数组, 那就是如果我选择下标`4`中的点数, 那下标`3, 5`中的点数就不能再选择了.

## 算法原理

- **状态表示**

  定义`f[i]`为选到`i`位置并且选择`i`时的最大获取点数, 定义`g[i]`为选到`i`位置并且不选择`i`时的最大获取点数. 

- **状态转移**

  如果你选到`i`位置并且还选择了`i`, 那么, 此时的最大点数就是从`0`到`i-1`位置的最大点数, 并且, 这个最大点数是有条件的, 他必须不选择`i-1`位置, 那这不就是`g[i-1]`吗?  所以`f[i] = nums[i] + g[i-1]`

  如果你选到`i`位置, 并且 一定不选择`i`, 那么此时的最大点数就是`0`到`i-1`位置的最大点数, 而且此时对是否选择`i-1`没有要求, 所以我们只需要从`g[i-1]`和`f[i-1]`中选一个最大的, 就行了. 所以`g[i] = max(g[i-1], f[i-1])`

- **初始化**

  对于第一个格子来说, 也就是下标为零的格子来说, 由于它前面已经没有格子, 所以需要进行初始化, 以防止其越界, 对于第一个格子来说, 如果选择了它, 那点数就是它自身, 如果没有选择, 那因为前面没有点数, 所以一个点数都得不到, 也就是零, 但零其实也不用特意初始化, 因为`int`的默认构造是零.

- **填表顺序**

  依据状态转移方程, 推导当前位置需要上一个位置的参与, 所以填表顺序很明显是从左往右

- **返回值**

  很明显, 是最后一个格子的最大点数, 最后一个格子有两种情况, `g[n-1]`和`f[n-1]`, 选择其中更大的那一个就行了.

## 代码编写

```cpp
class Solution {
    int _max(const vector<int>& nums_)
    {
        int result = 0;
        for(auto e : nums_)
            result = max(result, e);
        
        return result;
    }

    int rob(const vector<int>& nums)
    {
        int n = nums.size();
        vector<int> f(n), g(n);
        f[0] = nums[0];
        for(int i = 1; i < n; ++i)
        {
            f[i] = nums[i] + g[i-1];
            g[i] = max(f[i-1], g[i-1]);
        }
        return max(f[n-1], g[n-1]);
    }

public:
    int deleteAndEarn(vector<int>& nums_) {
        int temp = _max(nums_);
        vector<int> nums(temp+1);
        for(auto e : nums_)
        {
            nums[e] += e;
        }
        return rob(nums);
    }
};

/*
	第二次重写

    我们将会对获得的数组进行循环式的操作在每轮循环中, 我们将会选择其中的一个
    元素nums[i], 之后你将要所有nums[i] - 1 和nums[i] + 1的元素进行删除操作

    题目最终要求我们剩下的元素最大化.由于最后我们研究的是剩下的元素所以我们不
    妨把删除换一种我们更熟悉的说法, 选择, 对于那些被删除的元素就不能进行选择

    因此, 题目就变成了如果你选择nums[i], 那么就不能选择nums[i] - 1 以及 
    nums[i] + 1, 这与我们之前做过的在位置上相邻位置不能被再次选择略有相似
    之处, 不过, 还不够, 因为这里仅仅是数值上的相邻, 我们必须要把它们转化成
    位置上的相邻, 并且, 由于可能会出现数值相同的元素, 并且, 在转化过程中, 我
    们还必须确保转化过程的唯一性, 因为位置就是唯一性的, 

    为满足上述的要求, 我们选择哈希作为我们转化过程的媒介, 我们将会依据数值
    作为哈希中的下标, 进行映射, 哈希中的每个下标, 表示该数值在数组中对应的
    权重, 也就是原数组中所有相同数值的和, 我们将会通过哈希碰撞的方式, 来确保
    转化过程中的唯一性, 相同的数值将会映射到哈希中相同的位置上, 而这个位置将
    存储这些相同元素的和, 这也满足题目中, 对"所有"数值相邻进行删除的要求

    在经过上面的转化过程后, 那些数组中没有的元素, 将不会命中哈希中的对应位置
    它们的数值仍旧是零, 这样选不选效果相同, 此时数值上的相邻已经被完全转化成了位
    置上的相邻,  如果我们选择了一个位置, 就不能选择其相邻的位置, 在实际过程中
    我们不会把相邻元素同时进行处理, 当选择一个元素后, 我们将不会选择前面的相邻
    元素, 而不会考虑后面的相邻元素, 后面的相邻元素将在下下个位置的选择中被被自然的
    处理

     哈希规模 考虑到题目中给出的数组元素范围 1 <= nums[i] <= 10000, 尽管它并没有
     包括零, 但我们为了能够建立直接映射关系, 我们仍旧认为, 最大的下标是10000, 所以
     我们将要开辟10001的哈希大小, 不过, 其实也不需要进行直接映射, 因为最终我们考虑的
     都是位置上的相邻, 大家都减去一, 并不会改变彼此之前的相邻关系, 把零也包括进来的好
     处是, 多少个零相加还是零, 并且题目也说没有零, 所以此时动规表其实就不需要再初始化
     了

     动规规模, 就不细想了, 就和哈希同等规模吧
     定义[0]不选, [1]选择
*/

class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        int hash[10001] = {0};
        int n = 0;
        for(auto num : nums)
        {
            hash[num] += num;
            n = max(num, n);
        }

        int dp[10001][2] = {0};

        for(int i = 1; i <= n; ++i)
        {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
            dp[i][1] = dp[i-1][0] + hash[i];
        }

        return max(dp[n][0], dp[n][1]);
    }
};
```

# 完