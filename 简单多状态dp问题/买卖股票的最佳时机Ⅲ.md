# [买卖股票的最佳时机Ⅲ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii)

![image-20250404120912966](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250404120913067.png)

## 题目解析

还是买股票, 给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。与以往不同的是, 这次股票交易是有次数上限的, 以往, 你可以交易零次, 一次, 两次....一百次....., 哪种利润最大, 你就交易多少次, 但本题不一样, 它最多只能交易两次, 两次交易完成之后就必须要离场了, 就不能再交易了.    还是和之前一样, 这里表示的是一支股票的价格, 所以当你已经持有该股票时, 不能对它进行买入操作.

**示例一**

>```
>输入：prices = [3,3,5,0,0,3,1,4]
>输出：6
>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
>```

![image-20250404122714422](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250404122714462.png)

在第一天买入, 第三天卖出, 获利2, 完成一轮交易;   在第四天买入, 但不会在第六天卖出, 因为只剩下一轮交易机会了, 需要利益最大化, 所以在第八天卖出, 获利4, 总利润为六.

**示例二**

>```
>输入：prices = [1,2,3,4,5]
>输出：4
>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>```

行情一片大好, 所以第一天就买入, 然后等到最后一天抛售, 获利4

**示例三**

>```
>输入：prices = [7,6,4,3,1] 
>输出：0 
>解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
>```

行情一片大坏, 你选择什么都不做, 避免亏损, 获利0.

上面的三个示例, 分别对应完成两次交易, 完成一次交易, 完成零次交易, 具体选择多少次, 要看它利润大不大.

## 算法原理

- **状态表示**

  还是老样子, 即结合个人经验和题目要求, 定义`dp[i]`为 从第一天(下标为零)开始, 在第`i`天结束时的最大利润, 但很快, 我们意识到, 这个定义似乎有些太过宽泛了, 它不好表示题目中涉及到的某些信息, 所以我们深入一维, 定义`f[i]`为在第`i`天结束时, 处于持有状态的最大利润, 定义`g[i]`为, 在第`i`天结束时, 处于非持有状态的最大利润, 实际上, 对于之前的股票题目, 我们就是这样定义的, 但这种定义方式似乎还不够细, 因为很明显, 它无法描述交易的次数, 但我们这里的规定是, 最多只能进行两次交易, 所以我们再深入一维, 定义`f[i][j]`为, 在第`i`天结束时, 处于持有状态, 并且这个持有状态是在第`j`次交易中的最大利润, 定义`g[i][j]`为, 在第`i`天结束时,  处于非持有状态, 且这个非持有状态是在第`j`次交易中的最大利润, `j`表示已经完成的交易次数.

- **算法原理**

  还是老样子, 我们先画一下表示状态关系的图

  ![image-20250404130805592](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250404130805631.png)

  如果你已经持有一支股票, 那能不能继续持有呢? 当然可以, 你这一天什么都不做就行了.  不持有能不能到持有呢? 也可以, 买入股票即可,  对于不持有来说, 如果你本来就不持有股票, 能不能继续不持有呢? 当然可以, 你这一天什么都不做就行了, 持有能不能到不持有呢? 也可以, 卖出股票即可, 需要注意的是当你卖出一支股票, 就意味着完成了一轮交易, 所以你就需要对交易次数加一.

  当你一天结束之后处于持有状态, 那有两种可能, 一是, 前一天你就是持有, 另外的一种可能是, 前一天你不持有, 你这天依靠买入变为了持有状态, 因此, 就可得状态转移方程`f[i][j] = max(f[i-1][j], g[i-1][j] - prices[i]);`

  当你一天结束后处于非持有状态, 哪有两种可能, 一是, 前一天你就是没持有, 另外的一种可能是, 前一天你是有股票, 但依靠卖出变成了不持有, 因此, 就可得对应的状态转移方程`g[i][j] = max(g[i-1][j], f[i-1][j-1] + prices[i])`

- **初始化**

  在初始化阶段, 我们要考虑可能的越界问题. 光差状态转移方程, 可以知道, 它有两种越界可能, 一是行越界, 而是列越界. 该如何处理越界呢?  根据之前我们所做的题目, 也就是个人经验, 我们知道, 处理越界现在我们有两种思路, 一是增加虚拟位置, 二是直接初始.  选哪一个呢?   我们决定选择直接初始化, 当初我们选择虚拟位置方案, 是为了图省事, 但这里感觉, 如果再引入虚拟位置, 虚拟位置的初始化似乎会更加困难, 所以我们就不用这种思路了.

  如果选择直接初始化, 由于行和列都可能越界, 所以我们应该对第一行和第一列都进行初始化, 但我觉得, 对于列来说, 它实际上只有在一个地方上才可能出现越界问题, 我觉得其实不必这么大费周章, 连第一列都要初始化. 为此我们可以回到状态转移方程哪里, 对原先的状态转移方程引入限制条件, 限制它, 使之不会越界.

  列越界只存在一种可能`g[i][j] = max(g[i-1][j], f[i-1][j-1] + prices[i])`, 观察这个状态转移方程, 我们发现, (在行初始化完成的前提下), `g[i-1][j]`是不会越界的, 越界的只可能是`f[i-1][j-1] + prices[i]`, 所以我们可以先让`g[i][j]`变为`g[i-1][j]`, 然后加个`if`语句判断`j-1`有没有越界, 在没有越界的前提之下再进行大小比较, 这样, 我们就不必考虑列越界了.

  对于行越界, 我们则是要正经初始化. 我们的初始化原则是不能影响到后续环节的判断, 很明显, 在第一天, 不可能存在交易次数为1或者2的可能, 这意味着, 第二行的第二列, 它在进行填表时, 它的状态只能从第一行的第一列继承, 而不能从第一行的第二列继承, 因为这是一个不应该存在的位置

  ![image-20250404135352190](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250404135352250.png)

  我们是依靠谁来选择上一次状态的呢? 是依靠`max`, 因此, 我们想让`max`不选上一个值只需要将它的值变得足够小就行了, 比如`INT_MIN`, 因为值很小, 所以它只是参与比较, 但不会被真正使用. (第二行第三列确实会继承第一行第三列的值, 但一个足够小的数加上`p[i]`, 仍然是足够小的, 所以对于第三行第三列来说, 它仍然会从第二行第二列那里继承状态)

  但我们也不能真的使用`INT_MIN`, 因为我们有个方程是减去`p[i]`, 所以就会溢出, 因此这里对于"足够小"的力度有些要求, 对于这种情况来说, 我们一般喜欢用`0x3f3f3f3f`这个数, 足够大就是`0x3f3f3f3f`, 足够小就是`-0x3f3f3f3f`, 以此来防止数值溢出.

  之后我们对`f, g`进行一下具体分析, `f[0][0]`表示第一天买入, 所以应该是`-p[i]`, `g[0][0]`表示第一天什么都不做, 所以是`0`, 至于第一行的其它列, 那都是`-0x3f3f3f3f`.

- **填表顺序**

  从左往右, 从上到下

- **返回值**

  首先我们就不考虑持有状态了, 很明显, 卖出再获利显然利润更高, 之后, 由于可能进行零次交易, 一次交易, 二次交易, 所以你要遍历一遍, 找出其中的最大值

## 代码编写

```cpp
class Solution {
    const int INF = 0x3f3f3f3f;
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> g(n, vector<int>(3, -INF));
        auto f = g; f[0][0] = -prices[0];g[0][0] = 0;
        for(int i = 1; i < n; ++i)
        {
            for(int j = 0; j < 3; ++j)
            {
                f[i][j] = max(f[i-1][j], g[i-1][j] - prices[i]);
                g[i][j] = g[i-1][j];
                if(j-1 >= 0) g[i][j] = max(g[i][j], f[i-1][j-1] + prices[i]);
            }
        }

        int result = -INF;
        for(int i = 0; i < 3; ++i)
        {
            result = max(result, g[n-1][i]);
        }
        return result;
    }
};
```

这份代码的时间复杂度是$O(N)$, 因为那个列是常数, 所以可以略去, 至于空间复杂度, 还是因为列是常数, 所以还是$O(N)$, 但这份代码的用时分步可能不太好看, 那是因为很多人他用的并不是上面的算法原理, 他们的状态分为第一次持有, 第二次持有什么的, 在结构上比我们要简单, 所以时间分步不好看, 但时间复杂度级别都是一样的, 这里之所以用这种思路, 是因为它具有泛用性, 在买卖股票的最佳时机Ⅳ里可以完全复用.

# 完